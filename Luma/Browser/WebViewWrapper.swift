// Luma MVP - autogenerated by Cursor
import Foundation
import WebKit
import SwiftUI
import Combine
import AppKit

/// Manages one WKWebView per tab. Safe configuration, no message handlers.
/// Exposes page theme (background color) for chrome unification.
/// Handles file downloads via WKDownloadDelegate; saves to ~/Downloads and notifies DownloadManager.
final class WebViewWrapper: NSObject, ObservableObject, WKNavigationDelegate, WKDownloadDelegate, WKUIDelegate {
    private var webViews: [UUID: WKWebView] = [:]
    private(set) var activeTab: UUID?
    @Published var currentURL: URL?

    /// Per-tab page theme: background color and whether it is dark (for contrasting text).
    fileprivate var pageThemeByTab: [UUID: (color: NSColor, isDark: Bool)] = [:]
    /// Theme for the currently active tab; used by chrome (tabs, address bar) to match page.
    @Published var pageThemeForActiveTab: (color: Color, isDark: Bool)?

    /// Back/forward state for the active tab (updated in didFinish and when navigating).
    private var canGoBackByTab: [UUID: Bool] = [:]
    private var canGoForwardByTab: [UUID: Bool] = [:]
    @Published var canGoBackForActiveTab: Bool = false
    @Published var canGoForwardForActiveTab: Bool = false

    /// Pending download destination info for WKDownloadDelegate (keyed by ObjectIdentifier of WKDownload).
    private var downloadDestinationByID: [ObjectIdentifier: (fileURL: URL, requestURL: URL?, suggestedFilename: String)] = [:]

    /// Per-tab zoom (1.0 = 100%). Applied via document.body.style.zoom after load.
    private var zoomByTab: [UUID: CGFloat] = [:]
    private let zoomMin: CGFloat = 0.5
    private let zoomMax: CGFloat = 3.0
    private let zoomStep: CGFloat = 0.10

    /// Single message handler for theme; added to each webview config so we know which tab sent the message via message.webView.
    private lazy var themeMessageHandler: ThemeMessageHandler = {
        let h = ThemeMessageHandler()
        h.wrapper = self
        return h
    }()

    /// Script runs at documentEnd so theme color is available as soon as the page renders (O(1) relative to load).
    private static let themeScriptSource = """
        (function(){
            var el = document.body || document.documentElement;
            if (!el) return;
            var bg = window.getComputedStyle(el).backgroundColor;
            if (!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)') { el = document.documentElement; bg = el ? window.getComputedStyle(el).backgroundColor : null; }
            if (!bg || bg === 'transparent') { window.webkit.messageHandlers.lumaPageTheme.postMessage(''); return; }
            var m = bg.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);
            if (m) { window.webkit.messageHandlers.lumaPageTheme.postMessage(m[1]+','+m[2]+','+m[3]); return; }
            var m2 = bg.match(/rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);
            if (m2) { window.webkit.messageHandlers.lumaPageTheme.postMessage(m2[1]+','+m2[2]+','+m2[3]); return; }
            if (bg.indexOf('#') === 0 && bg.length >= 7) { var r=parseInt(bg.slice(1,3),16),g=parseInt(bg.slice(3,5),16),b=parseInt(bg.slice(5,7),16); window.webkit.messageHandlers.lumaPageTheme.postMessage(r+','+g+','+b); return; }
            if (bg.length === 4) { var r=parseInt(bg[1]+bg[1],16),g=parseInt(bg[2]+bg[2],16),b=parseInt(bg[3]+bg[3],16); window.webkit.messageHandlers.lumaPageTheme.postMessage(r+','+g+','+b); return; }
            window.webkit.messageHandlers.lumaPageTheme.postMessage('');
        })();
        """

    /// User-Agent matching current Safari on macOS so Google Workspace / Gmail treat the app as a supported browser.
    private static let safariLikeUserAgent =
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15"

    func ensureWebView(for tabId: UUID) -> WKWebView {
        if let wv = webViews[tabId] { return wv }
        let config = WKWebViewConfiguration()
        config.websiteDataStore = .default()
        config.userContentController.add(themeMessageHandler, name: "lumaPageTheme")
        let themeScript = WKUserScript(source: WebViewWrapper.themeScriptSource, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        config.userContentController.addUserScript(themeScript)
        let wv = WKWebView(frame: .zero, configuration: config)
        wv.customUserAgent = WebViewWrapper.safariLikeUserAgent
        wv.navigationDelegate = self
        wv.uiDelegate = self
        webViews[tabId] = wv
        return wv
    }

    func tabId(for webView: WKWebView) -> UUID? {
        webViews.first(where: { $0.value === webView })?.key
    }

    func canGoBack(in tabId: UUID) -> Bool {
        webViews[tabId]?.canGoBack ?? false
    }

    func canGoForward(in tabId: UUID) -> Bool {
        webViews[tabId]?.canGoForward ?? false
    }

    func setActiveTab(_ tabId: UUID) {
        activeTab = tabId
        currentURL = webViews[tabId]?.url
        updatePageThemeForActiveTab()
        updateBackForwardForActiveTab()
    }

    func load(url: URL, in tabId: UUID) {
        let wv = ensureWebView(for: tabId)
        if url.isFileURL {
            // Use loadFileURL so PDF/Word/etc. display in-browser like Chrome (sandbox-safe)
            let readAccessTo = url.deletingLastPathComponent()
            wv.loadFileURL(url, allowingReadAccessTo: readAccessTo)
        } else {
            let request = URLRequest(url: url)
            wv.load(request)
        }
        if activeTab == tabId {
            currentURL = url
        }
    }

    func goBack(in tabId: UUID) {
        guard let wv = webViews[tabId], wv.canGoBack else { return }
        wv.goBack()
    }

    func goForward(in tabId: UUID) {
        guard let wv = webViews[tabId], wv.canGoForward else { return }
        wv.goForward()
    }

    func reload(in tabId: UUID) {
        webViews[tabId]?.reload()
    }

    // MARK: - Zoom (Cmd+ / Cmd- / Cmd0)

    func zoomIn(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        let current = zoomByTab[id] ?? 1.0
        setZoom(min(current + zoomStep, zoomMax), for: id)
    }

    func zoomOut(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        let current = zoomByTab[id] ?? 1.0
        setZoom(max(current - zoomStep, zoomMin), for: id)
    }

    func zoomReset(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        setZoom(1.0, for: id)
    }

    private func setZoom(_ zoom: CGFloat, for tabId: UUID) {
        zoomByTab[tabId] = zoom
        applyZoom(to: tabId)
    }

    private func applyZoom(to tabId: UUID) {
        guard let wv = webViews[tabId] else { return }
        let zoom = zoomByTab[tabId] ?? 1.0
        let js = "document.body.style.zoom = \(zoom); document.documentElement.style.zoom = \(zoom);"
        wv.evaluateJavaScript(js, completionHandler: nil)
    }

    func evaluateSelectedText(in tabId: UUID, completion: @escaping (String?) -> Void) {
        guard let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("window.getSelection().toString()") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Convenience for AI command surface: uses active tab.
    func evaluateSelectedText(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        evaluateSelectedText(in: tabId, completion: completion)
    }

    /// Extracts the page title from the active tab.
    func evaluatePageTitle(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("document.title") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let title = result as? String, !title.isEmpty {
                    completion(title)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Extracts visible text from the page, bounded to maxChars (default 4000, hard max 12000 per AGENTS.md).
    func evaluateVisibleText(maxChars: Int = 4000, completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        let limit = min(maxChars, 12000)
        let js = "document.body.innerText.substring(0, \(limit))"
        wv.evaluateJavaScript(js) { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Removes a tab's WebView when the tab is closed.
    func removeWebView(for tabId: UUID) {
        webViews.removeValue(forKey: tabId)
        pageThemeByTab.removeValue(forKey: tabId)
        zoomByTab.removeValue(forKey: tabId)
        canGoBackByTab.removeValue(forKey: tabId)
        canGoForwardByTab.removeValue(forKey: tabId)
        if activeTab == tabId {
            activeTab = nil
            currentURL = nil
            pageThemeForActiveTab = nil
            canGoBackForActiveTab = false
            canGoForwardForActiveTab = false
        } else {
            updatePageThemeForActiveTab()
            updateBackForwardForActiveTab()
        }
    }

    // MARK: - WKNavigationDelegate

    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, preferences: WKWebpagePreferences, decisionHandler: @escaping (WKNavigationActionPolicy, WKWebpagePreferences) -> Void) {
        if navigationAction.shouldPerformDownload {
            decisionHandler(.download, preferences)
        } else {
            decisionHandler(.allow, preferences)
        }
    }

    /// MIME types we display in the WebView; everything else (PDF, Word, ZIP, etc.) downloads.
    private static let displayableMIMETypes: Set<String> = [
        "text/html", "text/plain", "text/css", "text/javascript", "application/javascript",
        "application/json", "application/xml", "image/svg+xml",
        "image/jpeg", "image/png", "image/gif", "image/webp", "image/bmp", "image/x-icon"
    ]

    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
        // 0) Local file:// URLs: always display in browser (don't treat as download)
        if navigationResponse.response.url?.scheme?.lowercased() == "file" {
            decisionHandler(.allow)
            return
        }
        // 1) Server says "save as file" â†’ always download
        if let http = navigationResponse.response as? HTTPURLResponse,
           let disposition = http.value(forHTTPHeaderField: "Content-Disposition"),
           disposition.lowercased().contains("attachment") {
            decisionHandler(.download)
            return
        }
        // 2) Main-frame navigation to remote image/* (HEIC, PNG, JPEG, etc.): download to Downloads
        //    (subresources like <img> on a page stay allowed so images display)
        let scheme = navigationResponse.response.url?.scheme?.lowercased()
        let mime = (navigationResponse.response.mimeType ?? "").lowercased()
        if navigationResponse.isForMainFrame,
           (scheme == "http" || scheme == "https"),
           mime.hasPrefix("image/") {
            decisionHandler(.download)
            return
        }
        // 3) Display only web/document content; all other types (PDF, Word, etc.) download
        let isDisplayable: Bool = {
            if mime.isEmpty { return true }
            if Self.displayableMIMETypes.contains(mime) { return true }
            if mime.hasPrefix("image/") { return true }
            if mime.hasPrefix("text/") { return true }
            return false
        }()
        if isDisplayable && navigationResponse.canShowMIMEType {
            decisionHandler(.allow)
        } else {
            decisionHandler(.download)
        }
    }

    func webView(_ webView: WKWebView, navigationAction: WKNavigationAction, didBecome download: WKDownload) {
        download.delegate = self
    }

    func webView(_ webView: WKWebView, navigationResponse: WKNavigationResponse, didBecome download: WKDownload) {
        download.delegate = self
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        guard let tabId = webViews.first(where: { $0.value === webView })?.key else { return }
        if tabId == activeTab {
            DispatchQueue.main.async { [weak self] in
                self?.currentURL = webView.url
            }
        }
        // Update back/forward state so toolbar buttons enable/disable correctly.
        canGoBackByTab[tabId] = webView.canGoBack
        canGoForwardByTab[tabId] = webView.canGoForward
        updateBackForwardForActiveTab()
        // Re-apply per-tab zoom after load
        applyZoom(to: tabId)
        // Fallback: sample theme again at load end (documentEnd script may have already run).
        let script = """
        (function(){
            var el = document.body || document.documentElement;
            if (!el) return null;
            var bg = window.getComputedStyle(el).backgroundColor;
            if (!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)') { el = document.documentElement; bg = el ? window.getComputedStyle(el).backgroundColor : null; }
            if (!bg || bg === 'transparent') return null;
            var m = bg.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);
            if (m) return m[1] + ',' + m[2] + ',' + m[3];
            var m2 = bg.match(/rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);
            if (m2) return m2[1] + ',' + m2[2] + ',' + m2[3];
            if (bg.indexOf('#') === 0 && bg.length >= 7) { var r=parseInt(bg.slice(1,3),16),g=parseInt(bg.slice(3,5),16),b=parseInt(bg.slice(5,7),16); return r+','+g+','+b; }
            if (bg.length === 4) { var r=parseInt(bg[1]+bg[1],16),g=parseInt(bg[2]+bg[2],16),b=parseInt(bg[3]+bg[3],16); return r+','+g+','+b; }
            return null;
        })();
        """
        webView.evaluateJavaScript(script) { [weak self] result, _ in
            guard let self = self else { return }
            let (color, isDark) = Self.parsePageTheme(result)
            DispatchQueue.main.async {
                if let color = color {
                    self.pageThemeByTab[tabId] = (color, isDark)
                } else {
                    self.pageThemeByTab.removeValue(forKey: tabId)
                }
                self.updatePageThemeForActiveTab()
            }
        }
    }

    fileprivate func updatePageThemeForActiveTab() {
        guard let id = activeTab, let theme = pageThemeByTab[id] else {
            pageThemeForActiveTab = nil
            return
        }
        pageThemeForActiveTab = (Color(nsColor: theme.color), theme.isDark)
    }

    private func updateBackForwardForActiveTab() {
        guard let id = activeTab else {
            canGoBackForActiveTab = false
            canGoForwardForActiveTab = false
            return
        }
        canGoBackForActiveTab = canGoBackByTab[id] ?? webViews[id]?.canGoBack ?? false
        canGoForwardForActiveTab = canGoForwardByTab[id] ?? webViews[id]?.canGoForward ?? false
    }

    /// Parse JS result (e.g. "255,255,255" or null) into NSColor and luminance-based isDark.
    fileprivate static func parsePageTheme(_ result: Any?) -> (NSColor?, Bool) {
        guard let str = result as? String, !str.isEmpty else { return (nil, false) }
        let parts = str.split(separator: ",").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }
        guard parts.count >= 3 else { return (nil, false) }
        let r = min(255, max(0, parts[0])), g = min(255, max(0, parts[1])), b = min(255, max(0, parts[2]))
        let ns = NSColor(red: CGFloat(r)/255, green: CGFloat(g)/255, blue: CGFloat(b)/255, alpha: 1)
        let luminance = (0.299 * CGFloat(r) + 0.587 * CGFloat(g) + 0.114 * CGFloat(b)) / 255
        return (ns, luminance < 0.5)
    }

    // MARK: - WKDownloadDelegate (saves to ~/Downloads, notifies DownloadManager)

    func download(_ download: WKDownload, decideDestinationUsing response: URLResponse, suggestedFilename: String, completionHandler: @escaping (URL?) -> Void) {
        let downloadsDir = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
        var dest = downloadsDir.appendingPathComponent(suggestedFilename)
        let pathExt = dest.pathExtension
        let base = dest.deletingPathExtension().lastPathComponent
        var counter = 1
        while FileManager.default.fileExists(atPath: dest.path) {
            let name = pathExt.isEmpty ? "\(base) (\(counter))" : "\(base) (\(counter)).\(pathExt)"
            dest = downloadsDir.appendingPathComponent(name)
            counter += 1
        }
        let requestURL = response.url ?? download.originalRequest?.url
        let id = ObjectIdentifier(download)
        downloadDestinationByID[id] = (dest, requestURL, suggestedFilename)
        completionHandler(dest)
    }

    func downloadDidFinish(_ download: WKDownload) {
        let id = ObjectIdentifier(download)
        guard let info = downloadDestinationByID.removeValue(forKey: id) else { return }
        let requestURL = info.requestURL ?? info.fileURL
        DownloadManager.shared.addDownload(url: requestURL, fileURL: info.fileURL, suggestedFilename: info.suggestedFilename)
    }

    // MARK: - WKUIDelegate (native file picker for <input type="file">)

    func webView(_ webView: WKWebView, runOpenPanelWith parameters: WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = parameters.allowsMultipleSelection
        panel.canChooseDirectories = parameters.allowsDirectories
        panel.canChooseFiles = true
        panel.begin { response in
            if response == .OK {
                completionHandler(panel.urls)
            } else {
                completionHandler(nil)
            }
        }
    }
}

// MARK: - Theme message handler (receives theme from documentEnd script for instant chrome color)

private final class ThemeMessageHandler: NSObject, WKScriptMessageHandler {
    weak var wrapper: WebViewWrapper?

    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        guard let wrapper = wrapper else { return }
        guard let wv = message.webView, let tabId = wrapper.tabId(for: wv) else { return }
        let (color, isDark) = WebViewWrapper.parsePageTheme(message.body)
        DispatchQueue.main.async {
            if let color = color {
                wrapper.pageThemeByTab[tabId] = (color, isDark)
            } else {
                wrapper.pageThemeByTab.removeValue(forKey: tabId)
            }
            wrapper.updatePageThemeForActiveTab()
        }
    }
}
