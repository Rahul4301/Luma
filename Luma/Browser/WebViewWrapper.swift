// Luma MVP - autogenerated by Cursor
import Foundation
import WebKit
import SwiftUI
import Combine
import AppKit

/// Manages one WKWebView per tab. Safe configuration, no message handlers.
/// Exposes page theme (background color) for chrome unification.
/// Handles file downloads via WKDownloadDelegate; saves to ~/Downloads and notifies DownloadManager.
///
/// Passwords & login: Uses persistent WKWebsiteDataStore.default() and a shared process pool
/// so cookies, localStorage, and site data (including credentials the system may use for
/// autofill) are saved and shared across tabs. Autofill of saved credentials works when
/// sites use standard autocomplete attributes. The system "Save Password" prompt is a
/// WebKit limitation in embedded WKWebView and may not appear; credentials saved in
/// Safari or elsewhere can still be used here when the system offers them.
final class WebViewWrapper: NSObject, ObservableObject, WKNavigationDelegate, WKDownloadDelegate, WKUIDelegate {
    /// Shared process pool so all tabs share the same credential/cookie store.
    private static let sharedProcessPool = WKProcessPool()

    private var webViews: [UUID: WKWebView] = [:]
    private(set) var activeTab: UUID?
    @Published var currentURL: URL?

    /// Per-tab page theme: background color and whether it is dark (for contrasting text).
    fileprivate var pageThemeByTab: [UUID: (color: NSColor, isDark: Bool)] = [:]
    /// Theme for the currently active tab; used by chrome (tabs, address bar) to match page.
    @Published var pageThemeForActiveTab: (color: Color, isDark: Bool)?

    /// Back/forward state for the active tab (updated in didFinish and when navigating).
    private var canGoBackByTab: [UUID: Bool] = [:]
    private var canGoForwardByTab: [UUID: Bool] = [:]
    @Published var canGoBackForActiveTab: Bool = false
    @Published var canGoForwardForActiveTab: Bool = false

    /// Pending download destination info for WKDownloadDelegate (keyed by ObjectIdentifier of WKDownload).
    private var downloadDestinationByID: [ObjectIdentifier: (fileURL: URL, requestURL: URL?, suggestedFilename: String)] = [:]

    /// Per-tab zoom (1.0 = 100%). Applied via document.body.style.zoom after load.
    private var zoomByTab: [UUID: CGFloat] = [:]
    private let zoomMin: CGFloat = 0.5
    private let zoomMax: CGFloat = 3.0
    private let zoomStep: CGFloat = 0.10
    
    /// KVO observations for title changes per tab
    private var titleObservations: [UUID: NSKeyValueObservation] = [:]
    
    /// KVO observations for URL changes per tab (for favicon updates)
    private var urlObservations: [UUID: NSKeyValueObservation] = [:]
    
    /// Favicon URLs per tab (extracted from page <link rel="icon">)
    @Published var faviconURLByTab: [UUID: URL?] = [:]
    
    /// When true, Google AI Studio showed "request is suspicious" — show in-app explanation (Google’s decision, not a Luma bug).
    @Published var googleSuspiciousErrorDetected: Bool = false
    
    /// TabManager reference for updating titles
    weak var tabManager: TabManager?

    /// Single message handler for theme; added to each webview config so we know which tab sent the message via message.webView.
    private lazy var themeMessageHandler: ThemeMessageHandler = {
        let h = ThemeMessageHandler()
        h.wrapper = self
        return h
    }()

    /// At documentStart: read theme-color meta only (instant, no layout). Many sites set it in <head>.
    private static let themeEarlyScriptSource = """
        (function(){
            if (!window.webkit || !window.webkit.messageHandlers.lumaPageTheme) return;
            var meta = document.querySelector('meta[name="theme-color"]');
            if (!meta || !meta.content) return;
            var c = (meta.content || '').trim();
            if (c.indexOf('#') === 0 && c.length >= 7) { var r=parseInt(c.slice(1,3),16),g=parseInt(c.slice(3,5),16),b=parseInt(c.slice(5,7),16); window.webkit.messageHandlers.lumaPageTheme.postMessage(r+','+g+','+b); return; }
            if (c.length === 4 && c[0]==='#') { var r=parseInt(c[1]+c[1],16),g=parseInt(c[2]+c[2],16),b=parseInt(c[3]+c[3],16); window.webkit.messageHandlers.lumaPageTheme.postMessage(r+','+g+','+b); }
        })();
        """

    /// Dia-style theme extraction at documentEnd: theme-color meta → CSS variables → body/root → header/main/first visible.
    /// Runs on all sites (including Gmail) so tab and address bar match site theme. MutationObserver + delayed samples for live updates.
    private static let themeScriptSource = """
        (function(){
            if (!window.webkit || !window.webkit.messageHandlers.lumaPageTheme) return;
            function parseColor(c) {
                if (!c || typeof c !== 'string') return null;
                c = c.trim();
                var m = c.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);
                if (m) return m[1]+','+m[2]+','+m[3];
                if (c.indexOf('#') === 0 && c.length >= 7) { var r=parseInt(c.slice(1,3),16),g=parseInt(c.slice(3,5),16),b=parseInt(c.slice(5,7),16); return r+','+g+','+b; }
                if (c.length === 4 && c[0]==='#') { var r=parseInt(c[1]+c[1],16),g=parseInt(c[2]+c[2],16),b=parseInt(c[3]+c[3],16); return r+','+g+','+b; }
                return null;
            }
            function send(rgb) { if (rgb) window.webkit.messageHandlers.lumaPageTheme.postMessage(rgb); else window.webkit.messageHandlers.lumaPageTheme.postMessage(''); }
            function bgFrom(el) {
                if (!el) return null;
                var bg = window.getComputedStyle(el).backgroundColor;
                if (!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)') return null;
                return parseColor(bg);
            }
            function sampleTheme() {
                var rgb = null;
                var meta = document.querySelector('meta[name="theme-color"]');
                if (meta && meta.content) rgb = parseColor(meta.content.trim());
                if (!rgb) {
                    var root = document.documentElement;
                    var style = root && window.getComputedStyle(root);
                    if (style) {
                        var v = style.getPropertyValue('--theme-color') || style.getPropertyValue('--primary') || style.getPropertyValue('--background') || style.getPropertyValue('--bg') || style.getPropertyValue('--color-primary');
                        if (v) rgb = parseColor(v.trim());
                    }
                }
                if (!rgb) rgb = bgFrom(document.body) || bgFrom(document.documentElement);
                if (!rgb && document.body) {
                    var candidates = document.querySelectorAll('header, [role="banner"], main, [role="main"], section, .hero, [class*="hero"], [class*="banner"], #header, .header, div');
                    for (var i = 0; i < Math.min(candidates.length, 12); i++) {
                        rgb = bgFrom(candidates[i]);
                        if (rgb) break;
                    }
                }
                send(rgb);
            }
            sampleTheme();
            var debounceTimer = null;
            function scheduleSample() {
                if (debounceTimer) clearTimeout(debounceTimer);
                debounceTimer = setTimeout(function() { sampleTheme(); debounceTimer = null; }, 100);
            }
            try {
                var mo = new MutationObserver(scheduleSample);
                mo.observe(document.documentElement, { attributes: true, attributeFilter: ['style', 'class', 'content'], subtree: true });
                if (document.body) mo.observe(document.body, { attributes: true, attributeFilter: ['style', 'class'], subtree: true });
            } catch(e) {}
            setTimeout(sampleTheme, 300);
            setTimeout(sampleTheme, 900);
        })();
        """

    /// User-Agent: standard Chromium on macOS so Google (Gmail, AI Studio, Cloud Console) treats the app as a normal browser.
    /// Avoids "request is suspicious" / bot detection when signing in or creating API keys.
    private static let chromeLikeUserAgent =
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"

    /// Some sites (notably certain library resolvers / enterprise portals) behave poorly with a spoofed UA
    /// inside embedded WebKit and may render a blank page. For these hosts, prefer the default WKWebView UA.
    private static func shouldUseDefaultUserAgent(for url: URL?) -> Bool {
        guard let host = url?.host?.lowercased() else { return false }
        // Ex Libris Alma/Primo resolvers
        if host.contains("exlibrisgroup.com") { return true }
        if host.contains("primo.exlibrisgroup.com") { return true }
        return false
    }

    /// Detects "Failed to generate API key, The request is suspicious" on AI Studio so we can show an in-app explanation.
    private static let googleSuspiciousErrorScriptSource = """
        (function(){
            if (!window.location.hostname || window.location.hostname.indexOf('aistudio.google.com') === -1) return;
            function check(){
                var b = document.body; if (!b) return;
                var t = (b.innerText || b.textContent || '').toLowerCase();
                if (t.indexOf('request is suspicious') !== -1 || t.indexOf('failed to generate api key') !== -1) {
                    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.lumaGoogleSuspiciousError) {
                        window.webkit.messageHandlers.lumaGoogleSuspiciousError.postMessage({});
                    }
                }
            }
            setTimeout(check, 1500); setTimeout(check, 3500);
        })();
        """

    private lazy var googleSuspiciousErrorHandler: GoogleSuspiciousErrorHandler = {
        let h = GoogleSuspiciousErrorHandler()
        h.wrapper = self
        return h
    }()

    func clearGoogleSuspiciousErrorBanner() {
        DispatchQueue.main.async { [weak self] in
            self?.googleSuspiciousErrorDetected = false
        }
    }

    func ensureWebView(for tabId: UUID) -> WKWebView {
        if let wv = webViews[tabId] { return wv }
        let config = WKWebViewConfiguration()
        config.processPool = WebViewWrapper.sharedProcessPool
        config.websiteDataStore = .default()
        // Explicitly enable JavaScript and normal storage so Google sign-in / API key flows work (cookies, localStorage).
        config.preferences.javaScriptEnabled = true
        // Enable Web Inspector + "Inspect Element" in context menu (macOS WebKit Developer Extras).
        config.preferences.setValue(true, forKey: "developerExtrasEnabled")
        if #available(macOS 11.0, *) {
            config.defaultWebpagePreferences.allowsContentJavaScript = true
        }
        config.userContentController.add(themeMessageHandler, name: "lumaPageTheme")
        config.userContentController.add(googleSuspiciousErrorHandler, name: "lumaGoogleSuspiciousError")
        let themeEarlyScript = WKUserScript(source: WebViewWrapper.themeEarlyScriptSource, injectionTime: .atDocumentStart, forMainFrameOnly: true)
        config.userContentController.addUserScript(themeEarlyScript)
        let themeScript = WKUserScript(source: WebViewWrapper.themeScriptSource, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        config.userContentController.addUserScript(themeScript)
        let googleErrorScript = WKUserScript(source: WebViewWrapper.googleSuspiciousErrorScriptSource, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        config.userContentController.addUserScript(googleErrorScript)
        let wv = WKWebView(frame: .zero, configuration: config)
        // Default to Chrome-like UA, but allow host-based fallback to WebKit UA when needed.
        wv.customUserAgent = WebViewWrapper.chromeLikeUserAgent
        wv.navigationDelegate = self
        wv.uiDelegate = self
        webViews[tabId] = wv
        
        // Observe title changes for this tab
        let titleObservation = wv.observe(\.title, options: [.new]) { [weak self, tabId] webView, change in
            guard let self = self, let title = webView.title, !title.isEmpty else { return }
            DispatchQueue.main.async {
                self.tabManager?.updateTitle(tab: tabId, title: title)
            }
        }
        titleObservations[tabId] = titleObservation
        
        // Observe URL changes to fetch favicon
        let urlObservation = wv.observe(\.url, options: [.new]) { [weak self, tabId] webView, change in
            guard let self = self, webView.url != nil else { return }
            self.fetchFavicon(for: tabId, webView: webView)
        }
        urlObservations[tabId] = urlObservation
        
        return wv
    }

    // MARK: - Printing

    /// Print the current page in the given tab (Cmd+P).
    func printPage(in tabId: UUID) {
        guard let wv = webViews[tabId] else { return }
        
        DispatchQueue.main.async {
            let printInfo = NSPrintInfo.shared
            printInfo.horizontalPagination = .fit
            printInfo.verticalPagination = .fit
            printInfo.isHorizontallyCentered = true
            printInfo.isVerticallyCentered = true
            
            let op = wv.printOperation(with: printInfo)
            
            // CRITICAL: Set the view's frame to avoid the crash:
            // "The NSPrintOperation view's frame was not initialized properly before knowsPageRange:"
            // The frame must be at least 100x100; it auto-resizes after.
            op.view?.frame = NSRect(x: 0, y: 0, width: max(wv.bounds.width, 100), height: max(wv.bounds.height, 100))
            
            op.showsPrintPanel = true
            op.showsProgressPanel = true
            
            // Run modally attached to the window
            if let window = wv.window ?? NSApp.keyWindow ?? NSApp.mainWindow {
                op.runModal(for: window, delegate: nil, didRun: nil, contextInfo: nil)
            } else {
                op.run()
            }
        }
    }

    func tabId(for webView: WKWebView) -> UUID? {
        webViews.first(where: { $0.value === webView })?.key
    }

    func canGoBack(in tabId: UUID) -> Bool {
        webViews[tabId]?.canGoBack ?? false
    }

    func canGoForward(in tabId: UUID) -> Bool {
        webViews[tabId]?.canGoForward ?? false
    }

    func setActiveTab(_ tabId: UUID) {
        activeTab = tabId
        currentURL = webViews[tabId]?.url
        updatePageThemeForActiveTab()
        updateBackForwardForActiveTab()
    }

    func load(url: URL, in tabId: UUID) {
        let wv = ensureWebView(for: tabId)
        // Per-host UA override (some hosts blank-screen with spoofed UA).
        if Self.shouldUseDefaultUserAgent(for: url) {
            wv.customUserAgent = nil
        } else {
            wv.customUserAgent = Self.chromeLikeUserAgent
        }
        if url.isFileURL {
            // Use loadFileURL so PDF/Word/etc. display in-browser like Chrome (sandbox-safe)
            let readAccessTo = url.deletingLastPathComponent()
            wv.loadFileURL(url, allowingReadAccessTo: readAccessTo)
        } else {
            var request = URLRequest(url: url)
            request.httpShouldHandleCookies = true
            wv.load(request)
        }
        if activeTab == tabId {
            currentURL = url
        }
    }

    func goBack(in tabId: UUID) {
        guard let wv = webViews[tabId], wv.canGoBack else { return }
        wv.goBack()
    }

    func goForward(in tabId: UUID) {
        guard let wv = webViews[tabId], wv.canGoForward else { return }
        wv.goForward()
    }

    func reload(in tabId: UUID) {
        webViews[tabId]?.reload()
    }

    // MARK: - Zoom (Cmd+ / Cmd- / Cmd0)

    func zoomIn(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        let current = zoomByTab[id] ?? 1.0
        setZoom(min(current + zoomStep, zoomMax), for: id)
    }

    func zoomOut(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        let current = zoomByTab[id] ?? 1.0
        setZoom(max(current - zoomStep, zoomMin), for: id)
    }

    func zoomReset(_ tabId: UUID?) {
        guard let id = tabId ?? activeTab else { return }
        setZoom(1.0, for: id)
    }

    private func setZoom(_ zoom: CGFloat, for tabId: UUID) {
        zoomByTab[tabId] = zoom
        applyZoom(to: tabId)
    }

    private func applyZoom(to tabId: UUID) {
        guard let wv = webViews[tabId] else { return }
        let zoom = zoomByTab[tabId] ?? 1.0
        let js = "document.body.style.zoom = \(zoom); document.documentElement.style.zoom = \(zoom);"
        wv.evaluateJavaScript(js, completionHandler: nil)
    }

    func evaluateSelectedText(in tabId: UUID, completion: @escaping (String?) -> Void) {
        guard let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("window.getSelection().toString()") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Convenience for AI command surface: uses active tab.
    func evaluateSelectedText(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        evaluateSelectedText(in: tabId, completion: completion)
    }

    /// Fetches the favicon URL from the page's <link rel="icon"> tag
    private func fetchFavicon(for tabId: UUID, webView: WKWebView) {
        let script = """
        (function() {
            var links = document.querySelectorAll('link[rel*="icon"]');
            for (var i = 0; i < links.length; i++) {
                var href = links[i].getAttribute('href');
                if (href) {
                    // Make absolute URL if relative
                    if (href.startsWith('//')) {
                        return window.location.protocol + href;
                    } else if (href.startsWith('/')) {
                        return window.location.origin + href;
                    } else if (!href.startsWith('http')) {
                        return window.location.origin + '/' + href;
                    }
                    return href;
                }
            }
            return '';
        })();
        """
        
        webView.evaluateJavaScript(script) { [weak self] result, error in
            guard let self = self else { return }
            DispatchQueue.main.async {
                if let urlString = result as? String, !urlString.isEmpty, let url = URL(string: urlString) {
                    self.faviconURLByTab[tabId] = url
                } else if let pageURL = webView.url, let host = pageURL.host {
                    // Fallback to /favicon.ico
                    self.faviconURLByTab[tabId] = URL(string: "https://\(host)/favicon.ico")
                } else {
                    self.faviconURLByTab[tabId] = nil
                }
            }
        }
    }
    
    /// Extracts the page title from the active tab.
    func evaluatePageTitle(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("document.title") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let title = result as? String, !title.isEmpty {
                    completion(title)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Extracts visible text from the page, bounded to maxChars (default 4000, hard max 12000 per AGENTS.md).
    func evaluateVisibleText(maxChars: Int = 4000, completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        evaluateVisibleText(for: tabId, maxChars: maxChars, completion: completion)
    }
    
    /// Extracts visible text from a specific tab, bounded to maxChars (default 4000, hard max 12000 per AGENTS.md).
    func evaluateVisibleText(for tabId: UUID, maxChars: Int = 4000, completion: @escaping (String?) -> Void) {
        guard let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        let limit = min(maxChars, 12000)
        let js = "document.body.innerText.substring(0, \(limit))"
        wv.evaluateJavaScript(js) { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }
    
    /// Evaluates page title for a specific tab.
    func evaluatePageTitle(for tabId: UUID, completion: @escaping (String?) -> Void) {
        guard let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("document.title") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let title = result as? String, !title.isEmpty {
                    completion(title)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Removes a tab's WebView when the tab is closed.
    func removeWebView(for tabId: UUID) {
        titleObservations.removeValue(forKey: tabId)
        urlObservations.removeValue(forKey: tabId)
        faviconURLByTab.removeValue(forKey: tabId)
        webViews.removeValue(forKey: tabId)
        pageThemeByTab.removeValue(forKey: tabId)
        zoomByTab.removeValue(forKey: tabId)
        canGoBackByTab.removeValue(forKey: tabId)
        canGoForwardByTab.removeValue(forKey: tabId)
        if activeTab == tabId {
            activeTab = nil
            currentURL = nil
            pageThemeForActiveTab = nil
            canGoBackForActiveTab = false
            canGoForwardForActiveTab = false
        } else {
            updatePageThemeForActiveTab()
            updateBackForwardForActiveTab()
        }
    }

    // MARK: - WKNavigationDelegate

    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, preferences: WKWebpagePreferences, decisionHandler: @escaping (WKNavigationActionPolicy, WKWebpagePreferences) -> Void) {
        if navigationAction.shouldPerformDownload {
            decisionHandler(.download, preferences)
            return
        }
        // Ensure JavaScript and normal web behavior so Google sign-in / API key flows work (no script blocking).
        preferences.allowsContentJavaScript = true
        decisionHandler(.allow, preferences)
    }

    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: any Error) {
        let url = webView.url?.absoluteString ?? "(unknown url)"
        print("WKWebView didFailProvisionalNavigation:", url, error.localizedDescription)
    }

    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: any Error) {
        let url = webView.url?.absoluteString ?? "(unknown url)"
        print("WKWebView didFail:", url, error.localizedDescription)
    }

    func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
        let url = webView.url?.absoluteString ?? "(unknown url)"
        print("WKWebView process terminated:", url)
    }

    /// MIME types we display in the WebView (PDF + web/image types). Word docs download to avoid gibberish.
    private static let displayableMIMETypes: Set<String> = [
        "text/html", "text/plain", "text/css", "text/javascript", "application/javascript",
        "application/json", "application/xml", "image/svg+xml",
        "image/jpeg", "image/png", "image/gif", "image/webp", "image/bmp", "image/x-icon",
        "application/pdf"
    ]

    func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
        // 0) Local file:// URLs: always display in browser (don't treat as download)
        if navigationResponse.response.url?.scheme?.lowercased() == "file" {
            decisionHandler(.allow)
            return
        }
        // 1) HTTP redirect (3xx): always allow so redirect chains (e.g. library resolvers, SSO) complete
        if let http = navigationResponse.response as? HTTPURLResponse,
           (300...399).contains(http.statusCode) {
            decisionHandler(.allow)
            return
        }
        // 2) Server says "save as file" → always download
        if let http = navigationResponse.response as? HTTPURLResponse,
           let disposition = http.value(forHTTPHeaderField: "Content-Disposition"),
           disposition.lowercased().contains("attachment") {
            decisionHandler(.download)
            return
        }
        // 3) Main-frame navigation to remote image/* (HEIC, PNG, JPEG, etc.): download to Downloads
        //    (subresources like <img> on a page stay allowed so images display)
        let scheme = navigationResponse.response.url?.scheme?.lowercased()
        let mime = (navigationResponse.response.mimeType ?? "").lowercased()
        let requestURL = navigationResponse.response.url
        if navigationResponse.isForMainFrame,
           (scheme == "http" || scheme == "https"),
           mime.hasPrefix("image/") {
            decisionHandler(.download)
            return
        }
        // 4) Display web/document content; always allow resolver/document URLs (e.g. Primo, Alma) even with wrong MIME
        if navigationResponse.isForMainFrame, (scheme == "http" || scheme == "https"),
           Self.looksLikeDocumentURL(requestURL) {
            decisionHandler(.allow)
            return
        }
        // 5) Standard displayable types
        let isDisplayable: Bool = {
            if mime.isEmpty { return true }
            if Self.displayableMIMETypes.contains(mime) { return true }
            if mime.hasPrefix("image/") { return true }
            if mime.hasPrefix("text/") { return true }
            if mime == "application/xhtml+xml" { return true }
            return false
        }()
        if isDisplayable && navigationResponse.canShowMIMEType {
            decisionHandler(.allow)
        } else {
            decisionHandler(.download)
        }
    }

    /// URLs that are typically HTML documents (resolvers, .do, /view/, etc.) so we allow display even when MIME is wrong.
    private static func looksLikeDocumentURL(_ url: URL?) -> Bool {
        guard let url = url else { return false }
        let s = url.absoluteString.lowercased()
        let path = url.path.lowercased()
        return path.contains("/view/") || path.contains("/action/") || path.hasSuffix(".do") || s.contains("uresolver") || s.contains("resolver")
    }

    func webView(_ webView: WKWebView, navigationAction: WKNavigationAction, didBecome download: WKDownload) {
        download.delegate = self
    }

    func webView(_ webView: WKWebView, navigationResponse: WKNavigationResponse, didBecome download: WKDownload) {
        download.delegate = self
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        guard let tabId = webViews.first(where: { $0.value === webView })?.key else { return }
        if tabId == activeTab {
            DispatchQueue.main.async { [weak self] in
                self?.currentURL = webView.url
            }
        }
        // Update back/forward state so toolbar buttons enable/disable correctly.
        canGoBackByTab[tabId] = webView.canGoBack
        canGoForwardByTab[tabId] = webView.canGoForward
        updateBackForwardForActiveTab()
        // Re-apply per-tab zoom after load
        applyZoom(to: tabId)
        // Fallback: sample theme again at load end (documentEnd script may have already run).
        let script = """
        (function(){
            var el = document.body || document.documentElement;
            if (!el) return null;
            var bg = window.getComputedStyle(el).backgroundColor;
            if (!bg || bg === 'transparent' || bg === 'rgba(0, 0, 0, 0)') { el = document.documentElement; bg = el ? window.getComputedStyle(el).backgroundColor : null; }
            if (!bg || bg === 'transparent') return null;
            var m = bg.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);
            if (m) return m[1] + ',' + m[2] + ',' + m[3];
            var m2 = bg.match(/rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);
            if (m2) return m2[1] + ',' + m2[2] + ',' + m2[3];
            if (bg.indexOf('#') === 0 && bg.length >= 7) { var r=parseInt(bg.slice(1,3),16),g=parseInt(bg.slice(3,5),16),b=parseInt(bg.slice(5,7),16); return r+','+g+','+b; }
            if (bg.length === 4) { var r=parseInt(bg[1]+bg[1],16),g=parseInt(bg[2]+bg[2],16),b=parseInt(bg[3]+bg[3],16); return r+','+g+','+b; }
            return null;
        })();
        """
        webView.evaluateJavaScript(script) { [weak self] result, _ in
            guard let self = self else { return }
            let (color, isDark) = Self.parsePageTheme(result)
            DispatchQueue.main.async {
                if let color = color {
                    self.pageThemeByTab[tabId] = (color, isDark)
                } else {
                    self.pageThemeByTab.removeValue(forKey: tabId)
                }
                self.updatePageThemeForActiveTab()
            }
        }
    }

    fileprivate func updatePageThemeForActiveTab() {
        guard let id = activeTab, let theme = pageThemeByTab[id] else {
            pageThemeForActiveTab = nil
            return
        }
        pageThemeForActiveTab = (Color(nsColor: theme.color), theme.isDark)
    }

    private func updateBackForwardForActiveTab() {
        guard let id = activeTab else {
            canGoBackForActiveTab = false
            canGoForwardForActiveTab = false
            return
        }
        canGoBackForActiveTab = canGoBackByTab[id] ?? webViews[id]?.canGoBack ?? false
        canGoForwardForActiveTab = canGoForwardByTab[id] ?? webViews[id]?.canGoForward ?? false
    }

    /// Parse JS result (e.g. "255,255,255" or null) into NSColor and luminance-based isDark.
    fileprivate static func parsePageTheme(_ result: Any?) -> (NSColor?, Bool) {
        guard let str = result as? String, !str.isEmpty else { return (nil, false) }
        let parts = str.split(separator: ",").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }
        guard parts.count >= 3 else { return (nil, false) }
        let r = min(255, max(0, parts[0])), g = min(255, max(0, parts[1])), b = min(255, max(0, parts[2]))
        let ns = NSColor(red: CGFloat(r)/255, green: CGFloat(g)/255, blue: CGFloat(b)/255, alpha: 1)
        let luminance = (0.299 * CGFloat(r) + 0.587 * CGFloat(g) + 0.114 * CGFloat(b)) / 255
        return (ns, luminance < 0.5)
    }

    // MARK: - WKDownloadDelegate (saves to ~/Downloads, notifies DownloadManager)

    func download(_ download: WKDownload, decideDestinationUsing response: URLResponse, suggestedFilename: String, completionHandler: @escaping (URL?) -> Void) {
        let downloadsDir = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
        var dest = downloadsDir.appendingPathComponent(suggestedFilename)
        let pathExt = dest.pathExtension
        let base = dest.deletingPathExtension().lastPathComponent
        var counter = 1
        while FileManager.default.fileExists(atPath: dest.path) {
            let name = pathExt.isEmpty ? "\(base) (\(counter))" : "\(base) (\(counter)).\(pathExt)"
            dest = downloadsDir.appendingPathComponent(name)
            counter += 1
        }
        let requestURL = response.url ?? download.originalRequest?.url
        let id = ObjectIdentifier(download)
        downloadDestinationByID[id] = (dest, requestURL, suggestedFilename)
        completionHandler(dest)
    }

    func downloadDidFinish(_ download: WKDownload) {
        let id = ObjectIdentifier(download)
        guard let info = downloadDestinationByID.removeValue(forKey: id) else { return }
        let requestURL = info.requestURL ?? info.fileURL
        DownloadManager.shared.addDownload(url: requestURL, fileURL: info.fileURL, suggestedFilename: info.suggestedFilename)
    }

    // MARK: - WKUIDelegate

    /// Handle `target="_blank"` / `window.open()` by creating a new tab *and returning a real WKWebView*.
    ///
    /// Important: returning `nil` breaks flows that depend on the opener relationship and/or the browser
    /// performing the navigation (proper `Referer`, cookies, redirects, and window scripting). Many library
    /// resolvers (Primo/Alma) rely on this behavior.
    func webView(_ webView: WKWebView, createWebViewWith configuration: WKWebViewConfiguration, for navigationAction: WKNavigationAction, windowFeatures: WKWindowFeatures) -> WKWebView? {
        guard navigationAction.targetFrame == nil else { return nil }
        guard let requestURL = navigationAction.request.url,
              let scheme = requestURL.scheme?.lowercased(),
              (scheme == "http" || scheme == "https" || scheme == "file") else {
            return nil
        }
        guard let tabManager = tabManager else { return nil }

        // Create a new tab and *return* its webview so WebKit performs the navigation with correct headers.
        let id = tabManager.newTab(url: requestURL)
        // IMPORTANT: the returned WKWebView must be created with the provided `configuration`,
        // otherwise WebKit throws: "Returned WKWebView was not created with the given configuration."
        //
        // CRITICAL FOR GOOGLE SIGN-IN: We must set the shared processPool and websiteDataStore
        // on the provided configuration so cookies/sessions are shared across all tabs.
        // Without this, Google OAuth popups create isolated sessions that don't persist.
        configuration.processPool = WebViewWrapper.sharedProcessPool
        configuration.websiteDataStore = .default()
        configuration.preferences.setValue(true, forKey: "developerExtrasEnabled")
        // Ensure JavaScript/content scripts are enabled for popup windows as well (Google/Gmail sign-in flows).
        configuration.preferences.javaScriptEnabled = true
        if #available(macOS 11.0, *) {
            configuration.defaultWebpagePreferences.allowsContentJavaScript = true
        }
        let wv = WKWebView(frame: .zero, configuration: configuration)
        if Self.shouldUseDefaultUserAgent(for: requestURL) {
            wv.customUserAgent = nil
        } else {
            wv.customUserAgent = WebViewWrapper.chromeLikeUserAgent
        }
        wv.navigationDelegate = self
        wv.uiDelegate = self
        webViews[id] = wv

        // Observe title changes for this tab
        let titleObservation = wv.observe(\.title, options: [.new]) { [weak self, id] webView, _ in
            guard let self = self, let title = webView.title, !title.isEmpty else { return }
            DispatchQueue.main.async {
                self.tabManager?.updateTitle(tab: id, title: title)
            }
        }
        titleObservations[id] = titleObservation

        // Observe URL changes to fetch favicon
        let urlObservation = wv.observe(\.url, options: [.new]) { [weak self, id] webView, _ in
            guard let self = self, webView.url != nil else { return }
            self.fetchFavicon(for: id, webView: webView)
        }
        urlObservations[id] = urlObservation

        setActiveTab(id)
        // Do NOT call `load()` here — WebKit will load `navigationAction.request` into the returned webview.
        return wv
    }

    func webView(_ webView: WKWebView, runOpenPanelWith parameters: WKOpenPanelParameters, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping ([URL]?) -> Void) {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = parameters.allowsMultipleSelection
        panel.canChooseDirectories = parameters.allowsDirectories
        panel.canChooseFiles = true
        panel.begin { response in
            if response == .OK {
                completionHandler(panel.urls)
            } else {
                completionHandler(nil)
            }
        }
    }
}

// MARK: - Theme message handler (receives theme from documentEnd script for instant chrome color)

private final class ThemeMessageHandler: NSObject, WKScriptMessageHandler {
    weak var wrapper: WebViewWrapper?

    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        guard let wrapper = wrapper else { return }
        guard let wv = message.webView, let tabId = wrapper.tabId(for: wv) else { return }
        let (color, isDark) = WebViewWrapper.parsePageTheme(message.body)
        DispatchQueue.main.async {
            if let color = color {
                wrapper.pageThemeByTab[tabId] = (color, isDark)
            } else {
                wrapper.pageThemeByTab.removeValue(forKey: tabId)
            }
            wrapper.updatePageThemeForActiveTab()
        }
    }
}

// MARK: - Google “suspicious request” handler (shows in-app explanation so users know it’s Google’s decision, not Luma)

private final class GoogleSuspiciousErrorHandler: NSObject, WKScriptMessageHandler {
    weak var wrapper: WebViewWrapper?

    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        DispatchQueue.main.async { [weak self] in
            self?.wrapper?.googleSuspiciousErrorDetected = true
        }
    }
}
