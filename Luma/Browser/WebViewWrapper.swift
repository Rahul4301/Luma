// Luma MVP - autogenerated by Cursor
import Foundation
import WebKit
import SwiftUI
import Combine

/// Manages one WKWebView per tab. Safe configuration, no message handlers.
final class WebViewWrapper: NSObject, ObservableObject, WKNavigationDelegate {
    private var webViews: [UUID: WKWebView] = [:]
    private(set) var activeTab: UUID?
    @Published var currentURL: URL?

    /// User-Agent matching current Safari on macOS so Google Workspace / Gmail treat the app as a supported browser.
    private static let safariLikeUserAgent =
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15"

    func ensureWebView(for tabId: UUID) -> WKWebView {
        if let wv = webViews[tabId] { return wv }
        let config = WKWebViewConfiguration()
        config.websiteDataStore = .default()
        let wv = WKWebView(frame: .zero, configuration: config)
        wv.customUserAgent = WebViewWrapper.safariLikeUserAgent
        wv.navigationDelegate = self
        webViews[tabId] = wv
        return wv
    }

    func setActiveTab(_ tabId: UUID) {
        activeTab = tabId
        currentURL = webViews[tabId]?.url
    }

    func load(url: URL, in tabId: UUID) {
        let wv = ensureWebView(for: tabId)
        let request = URLRequest(url: url)
        wv.load(request)
        if activeTab == tabId {
            currentURL = url
        }
    }

    func goBack(in tabId: UUID) {
        webViews[tabId]?.goBack()
    }

    func goForward(in tabId: UUID) {
        webViews[tabId]?.goForward()
    }

    func reload(in tabId: UUID) {
        webViews[tabId]?.reload()
    }

    func evaluateSelectedText(in tabId: UUID, completion: @escaping (String?) -> Void) {
        guard let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("window.getSelection().toString()") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Convenience for AI command surface: uses active tab.
    func evaluateSelectedText(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        evaluateSelectedText(in: tabId, completion: completion)
    }

    /// Extracts the page title from the active tab.
    func evaluatePageTitle(completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        wv.evaluateJavaScript("document.title") { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let title = result as? String, !title.isEmpty {
                    completion(title)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Extracts visible text from the page, bounded to maxChars (default 4000, hard max 12000 per AGENTS.md).
    func evaluateVisibleText(maxChars: Int = 4000, completion: @escaping (String?) -> Void) {
        guard let tabId = activeTab, let wv = webViews[tabId] else {
            DispatchQueue.main.async { completion(nil) }
            return
        }
        let limit = min(maxChars, 12000)
        let js = "document.body.innerText.substring(0, \(limit))"
        wv.evaluateJavaScript(js) { result, error in
            DispatchQueue.main.async {
                if error != nil {
                    completion(nil)
                    return
                }
                if let text = result as? String, !text.isEmpty {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        }
    }

    /// Removes a tab's WebView when the tab is closed.
    func removeWebView(for tabId: UUID) {
        webViews.removeValue(forKey: tabId)
        if activeTab == tabId {
            activeTab = nil
            currentURL = nil
        }
    }

    // MARK: - WKNavigationDelegate

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            guard self.activeTab != nil else { return }
            if let tabId = self.webViews.first(where: { $0.value === webView })?.key,
               tabId == self.activeTab {
                self.currentURL = webView.url
            }
        }
    }
}
