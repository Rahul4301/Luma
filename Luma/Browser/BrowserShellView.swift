// Luma MVP - autogenerated by Cursor
import SwiftUI
import WebKit
import AppKit
import Combine

/// Minimal browser shell hosting WKWebViews via WebViewWrapper and TabManager.
///
/// Per SRS: WebKit-only renderer, minimal tab UI, address bar.
/// Omnibox: accepts full URL, domain, or search query.
/// Per SECURITY.md: No JS message handlers, no HTML scraping.
struct BrowserShellView: View {
    @StateObject private var tabManager = TabManager()
    @StateObject private var web = WebViewWrapper()
    @State private var addressBarText: String = ""
    @State private var isCommandPanelPresented: Bool = false
    @State private var eventMonitor: Any?
    @State private var pendingAction: BrowserAction? = nil
    @State private var pendingAssistantText: String = ""
    @State private var showActionConfirm: Bool = false
    @FocusState private var addressBarFocused: Bool

    private let router = CommandRouter()
    private let gemini = GeminiClient(apiKeyProvider: { KeychainManager.shared.fetchGeminiKey() })

    var body: some View {
        HStack(spacing: 0) {
            VStack(spacing: 0) {
                // Top bar: Back, Forward, Reload, Address bar, Go, New Tab, Close Tab
                HStack(spacing: 8) {
                    Button(action: { if let id = tabManager.currentTab { web.goBack(in: id) } }) {
                        Image(systemName: "chevron.left")
                    }
                    .buttonStyle(.plain)

                    Button(action: { if let id = tabManager.currentTab { web.goForward(in: id) } }) {
                        Image(systemName: "chevron.right")
                    }
                    .buttonStyle(.plain)

                    Button(action: { if let id = tabManager.currentTab { web.reload(in: id) } }) {
                        Image(systemName: "arrow.clockwise")
                    }
                    .buttonStyle(.plain)

                    TextField("Search or enter URL", text: $addressBarText, onCommit: goToAddress)
                        .textFieldStyle(.roundedBorder)
                        .focused($addressBarFocused)

                    Button("Go") { goToAddress() }

                    Button(action: newTab) {
                        Image(systemName: "plus")
                    }
                    .buttonStyle(.plain)

                    Button(action: closeCurrentTab) {
                        Image(systemName: "xmark")
                    }
                    .buttonStyle(.plain)
                }
                .padding(8)

                // Tab strip
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 2) {
                        ForEach(tabManager.tabOrder, id: \.self) { tabId in
                            TabPill(
                                tabId: tabId,
                                url: tabManager.tabURL[tabId] ?? nil,
                                isActive: tabManager.currentTab == tabId,
                                onSelect: { switchToTab(tabId) },
                                onClose: { closeTab(tabId) }
                            )
                        }
                    }
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(Color(nsColor: .controlBackgroundColor))

                // Main content
                if let currentId = tabManager.currentTab {
                    WebViewContainer(webView: web.ensureWebView(for: currentId))
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .id(currentId)
                } else {
                    Color(nsColor: .windowBackgroundColor)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .overlay(Text("No tab").foregroundColor(.secondary))
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)

            if isCommandPanelPresented {
                CommandSurfaceView(
                    isPresented: $isCommandPanelPresented,
                    webViewWrapper: web,
                    commandRouter: router,
                    gemini: gemini
                ) { response in
                    pendingAssistantText = response.text
                    pendingAction = response.action
                    showActionConfirm = (response.action != nil)
                }
                .frame(width: 360)
                .background(Color(NSColor.windowBackgroundColor).opacity(0.95))
                .shadow(color: .black.opacity(0.2), radius: 8, x: -2, y: 0)
            }
        }
        .alert("Confirm Action", isPresented: $showActionConfirm) {
            Button("Cancel", role: .cancel) { pendingAction = nil }
            Button("Execute") { executePendingAction() }
        } message: {
            if let action = pendingAction {
                let typeText = action.type.rawValue
                let payloadKeys = action.payload?.keys.sorted() ?? []
                let payloadSummary = payloadKeys.isEmpty ? "none" : payloadKeys.joined(separator: ", ")
                Text("Assistant: \(pendingAssistantText)\n\nAction: \(typeText)\nPayload keys: \(payloadSummary)")
            } else {
                Text("No action to execute.")
            }
        }
        .onAppear {
            if tabManager.currentTab == nil {
                let url = URL(string: "https://example.com")!
                let id = tabManager.newTab(url: url)
                web.setActiveTab(id)
                web.load(url: url, in: id)
                addressBarText = url.absoluteString
            }
            eventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                if event.modifierFlags.contains(.command), event.charactersIgnoringModifiers == "e" {
                    DispatchQueue.main.async { isCommandPanelPresented.toggle() }
                    return nil
                }
                return event
            }
        }
        .onChange(of: tabManager.currentTab) { _, newId in
            if let id = newId {
                web.setActiveTab(id)
                syncAddressBarFromCurrentTab()
            } else {
                addressBarText = ""
            }
        }
        .onChange(of: web.currentURL) { _, _ in
            syncAddressBarFromCurrentTab()
        }
        .onDisappear {
            if let m = eventMonitor {
                NSEvent.removeMonitor(m)
                eventMonitor = nil
            }
        }
    }

    private func syncAddressBarFromCurrentTab() {
        if let id = tabManager.currentTab {
            if let url = web.currentURL {
                addressBarText = url.absoluteString
                tabManager.navigate(tab: id, to: url)
            } else if let url = tabManager.tabURL[id] ?? nil {
                addressBarText = url.absoluteString
            } else {
                addressBarText = ""
            }
        } else {
            addressBarText = ""
        }
    }

    /// Omnibox parsing: URL, domain, or search query.
    private func resolveToURL(_ input: String) -> URL? {
        let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        if trimmed.lowercased().hasPrefix("http://") || trimmed.lowercased().hasPrefix("https://") {
            return URL(string: trimmed)
        }

        if !trimmed.contains(" "), trimmed.contains(".") {
            return URL(string: "https://" + trimmed)
        }

        let encoded = trimmed.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? trimmed
        return URL(string: "https://www.google.com/search?q=" + encoded)
    }

    private func goToAddress() {
        guard let url = resolveToURL(addressBarText) else { return }

        if tabManager.currentTab == nil {
            let id = tabManager.newTab(url: url)
            web.setActiveTab(id)
            web.load(url: url, in: id)
        } else if let id = tabManager.currentTab {
            tabManager.navigate(tab: id, to: url)
            web.load(url: url, in: id)
        }
        addressBarText = url.absoluteString
    }

    private func newTab() {
        let id = tabManager.newTab(url: nil)
        web.setActiveTab(id)
        addressBarText = ""
        addressBarFocused = true
    }

    private func closeCurrentTab() {
        guard let id = tabManager.currentTab else { return }
        closeTab(id)
    }

    private func closeTab(_ id: UUID) {
        web.removeWebView(for: id)
        tabManager.closeTab(id)
        if tabManager.currentTab == nil {
            newTab()
        } else if let newCurrent = tabManager.currentTab {
            web.setActiveTab(newCurrent)
            syncAddressBarFromCurrentTab()
        }
    }

    private func switchToTab(_ id: UUID) {
        tabManager.switchToTab(id)
        web.setActiveTab(id)
        syncAddressBarFromCurrentTab()
    }


    private func executePendingAction() {
        guard let action = pendingAction else { return }

        let tabToClose: UUID?
        if action.type == .close_tab, action.payload?["index"] == nil {
            tabToClose = tabManager.currentTab
        } else {
            tabToClose = nil
        }

        let result = router.execute(action: action, tabManager: tabManager)
        switch result {
        case .success:
            if let id = tabToClose {
                web.removeWebView(for: id)
            }
            if action.type == .new_tab || action.type == .navigate,
               let urlString = action.payload?["url"],
               let url = URL(string: urlString.contains("://") ? urlString : "https://" + urlString) {
                if action.type == .new_tab, let id = tabManager.currentTab {
                    web.setActiveTab(id)
                    web.load(url: url, in: id)
                    tabManager.navigate(tab: id, to: url)
                    addressBarText = url.absoluteString
                } else if action.type == .navigate, let id = tabManager.currentTab {
                    web.load(url: url, in: id)
                    tabManager.navigateCurrentTab(to: url)
                    addressBarText = url.absoluteString
                }
            }
        case .failure:
            break
        }

        pendingAction = nil
    }
}

private struct TabPill: View {
    let tabId: UUID
    let url: URL?
    let isActive: Bool
    let onSelect: () -> Void
    let onClose: () -> Void

    private var title: String {
        url?.host ?? url?.absoluteString ?? "New Tab"
    }

    var body: some View {
        HStack(spacing: 4) {
            Button(action: onSelect) {
                Text(title)
                    .lineLimit(1)
                    .truncationMode(.tail)
                    .frame(maxWidth: 120)
            }
            .buttonStyle(.plain)
            .padding(.leading, 8)
            .padding(.vertical, 4)
            .background(isActive ? Color.accentColor.opacity(0.2) : Color.clear)
            .cornerRadius(4)

            Button(action: onClose) {
                Image(systemName: "xmark.circle.fill")
                    .font(.system(size: 10))
                    .foregroundColor(.secondary)
            }
            .buttonStyle(.plain)
        }
    }
}

struct WebViewContainer: NSViewRepresentable {
    let webView: WKWebView

    func makeNSView(context: Context) -> WKWebView { webView }
    func updateNSView(_ nsView: WKWebView, context: Context) {}
}

#Preview {
    BrowserShellView()
}
