// Luma MVP - autogenerated by Cursor
import SwiftUI
import WebKit
import AppKit

/// Minimal browser shell hosting a WKWebView via WebViewWrapper and TabManager.
///
/// Per SRS: WebKit-only renderer, minimal tab UI, address bar.
/// Per SECURITY.md: No JS message handlers, no HTML scraping.
struct BrowserShellView: View {
    @StateObject private var tabManager = TabManager()
    @StateObject private var web = WebViewWrapper()
    @State private var addressBarText: String = "https://example.com"
    @State private var isCommandSurfacePresented: Bool = false
    @State private var eventMonitor: Any?
    @State private var pendingAction: BrowserAction? = nil
    @State private var pendingAssistantText: String = ""
    @State private var showActionConfirm: Bool = false
    @State private var lastActionResultText: String = ""
    
    // Deterministic, reused dependencies for the command surface.
    private let router = CommandRouter()
    private let gemini = GeminiClient(apiKeyProvider: { KeychainManager.shared.fetchGeminiKey() })
    
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                // Top bar: address field + Go button
                HStack {
                    TextField("Enter URL", text: $addressBarText, onCommit: goToAddress)
                        .textFieldStyle(.roundedBorder)
                    Button("Go") {
                        goToAddress()
                    }
                }
                .padding()
                
                // Web content
                WebViewContainer(webViewWrapper: web)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            }
            
            // Command surface overlay
            if isCommandSurfacePresented {
                Color.black.opacity(0.25)
                    .ignoresSafeArea()
                
                VStack {
                    HStack {
                        Spacer()
                        Button("Close") {
                            toggleCommandSurface()
                        }
                        .keyboardShortcut(.escape, modifiers: [])
                    }
                    .padding(.horizontal)
                    
                    CommandSurfaceView(
                        isPresented: $isCommandSurfacePresented,
                        webViewWrapper: web,
                        commandRouter: router,
                        gemini: gemini
                    ) { response in
                        // Store latest proposed response for confirmation UI (no automatic execution).
                        pendingAssistantText = response.text
                        pendingAction = response.action
                        showActionConfirm = (response.action != nil)
                    }
                }
                .padding(.top, 40)
            }
        }
        .alert("Confirm Action", isPresented: $showActionConfirm) {
            Button("Cancel", role: .cancel) {
                pendingAction = nil
            }
            Button("Execute") {
                executePendingAction()
            }
        } message: {
            if let action = pendingAction {
                let typeText = action.type.rawValue
                let payloadKeys = action.payload?.keys.sorted() ?? []
                let payloadSummary = payloadKeys.isEmpty ? "none" : payloadKeys.joined(separator: ", ")
                Text("Assistant: \(pendingAssistantText)\n\nAction: \(typeText)\nPayload keys: \(payloadSummary)")
            } else {
                Text("No action to execute.")
            }
        }
        .onAppear {
            // On first launch, create a tab and load https://example.com
            if tabManager.currentTab == nil {
                if let url = URL(string: "https://example.com") {
                    _ = tabManager.newTab(url: url)
                    web.load(url: url)
                    addressBarText = url.absoluteString
                }
            } else if let currentId = tabManager.currentTab,
                      let url = tabManager.tabs[currentId] {
                addressBarText = url.absoluteString
                web.load(url: url)
            }
            
            // Install local key down monitor for Cmd+E
            eventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                if event.modifierFlags.contains(.command),
                   event.charactersIgnoringModifiers == "e" {
                    DispatchQueue.main.async {
                        toggleCommandSurface()
                    }
                    // Return nil to consume the event
                    return nil
                }
                return event
            }
        }
        .onDisappear {
            // Remove local event monitor if installed
            if let monitor = eventMonitor {
                NSEvent.removeMonitor(monitor)
                eventMonitor = nil
            }
        }
    }
    
    /// Normalizes and navigates to the URL in the address bar.
    private func goToAddress() {
        let trimmed = addressBarText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        
        let normalized: String
        if trimmed.contains("://") {
            normalized = trimmed
        } else {
            normalized = "https://" + trimmed
        }
        
        guard let url = URL(string: normalized) else {
            return
        }
        
        if tabManager.currentTab == nil {
            _ = tabManager.newTab(url: url)
        } else {
            tabManager.navigateCurrentTab(to: url)
        }
        
        web.load(url: url)
        addressBarText = normalized
    }
    
    /// Toggles the AI command surface overlay visibility.
    private func toggleCommandSurface() {
        isCommandSurfacePresented.toggle()
    }
    
    /// Executes the pending action after explicit user confirmation.
    private func executePendingAction() {
        guard let action = pendingAction else { return }
        
        // Deterministic, single action execution per confirmation.
        let result = router.execute(action: action, tabManager: tabManager)
        switch result {
        case .success(let message):
            lastActionResultText = "Success: \(message)"
        case .failure(let error):
            lastActionResultText = "Error: \(error.localizedDescription)"
        }
        
        pendingAction = nil
    }
}

/// SwiftUI host for WKWebView using the existing WebViewWrapper.
struct WebViewContainer: NSViewRepresentable {
    let webViewWrapper: WebViewWrapper
    
    func makeNSView(context: Context) -> WKWebView {
        // Use the WKWebView managed by WebViewWrapper.
        webViewWrapper.view
    }
    
    func updateNSView(_ nsView: WKWebView, context: Context) {
        // No-op: navigation is driven explicitly via WebViewWrapper.load(url:).
    }
}

#Preview {
    BrowserShellView()
}
