// Luma MVP - autogenerated by Cursor
import SwiftUI
import WebKit
import AppKit
import Combine
import UniformTypeIdentifiers

/// Minimal browser shell hosting WKWebViews via WebViewWrapper and TabManager.
///
/// Per SRS: WebKit-only renderer, minimal tab UI, address bar.
/// Omnibox: accepts full URL, domain, or search query.
/// Per SECURITY.md: No JS message handlers, no HTML scraping.
struct BrowserShellView: View {
    @StateObject private var tabManager = TabManager()
    @StateObject private var web = WebViewWrapper()
    @State private var addressBarText: String = ""
    @State private var tabsWithPanelOpen: Set<UUID> = []
    @State private var tabChatHistory: [UUID: [ChatMessage]] = [:]
    @State private var aiPanelWidth: CGFloat = 380
    @State private var eventMonitor: Any?
    @State private var pendingAction: BrowserAction? = nil
    @State private var pendingAssistantText: String = ""
    @State private var showActionConfirm: Bool = false
    @State private var showHistorySheet: Bool = false
    @State private var restoreAddressBarOnEscape: Bool = false
    @State private var isFirstLoad: Bool = true
    @FocusState private var addressBarFocused: Bool
    @State private var searchSuggestions: [String] = []
    @State private var suggestionDebounceTask: DispatchWorkItem?

    private let router = CommandRouter()
    private let gemini = GeminiClient(apiKeyProvider: { KeychainManager.shared.fetchGeminiKey() })

    private let addressBarHeight: CGFloat = 44
    private let chromeCornerRadius: CGFloat = 14
    private let chromePadding: CGFloat = 6

    var body: some View {
        ZStack {
            Color(nsColor: .windowBackgroundColor)
                .ignoresSafeArea()

            HStack(spacing: 0) {
                VStack(spacing: 0) {
                    // Address bar row (layout flow only - fixed height)
                    HStack(spacing: 6) {
                        // Nav buttons (rounded)
                        HStack(spacing: 2) {
                            Button(action: { if let id = tabManager.currentTab { web.goBack(in: id) } }) {
                                Image(systemName: "chevron.left")
                                    .font(.system(size: 11, weight: .medium))
                                    .frame(width: 28, height: 28)
                                    .background(RoundedRectangle(cornerRadius: 6).fill(Color(white: 0.22).opacity(0.6)))
                            }
                            .buttonStyle(.plain)
                            .accessibilityLabel("Back")

                            Button(action: { if let id = tabManager.currentTab { web.goForward(in: id) } }) {
                                Image(systemName: "chevron.right")
                                    .font(.system(size: 11, weight: .medium))
                                    .frame(width: 28, height: 28)
                                    .background(RoundedRectangle(cornerRadius: 6).fill(Color(white: 0.22).opacity(0.6)))
                            }
                            .buttonStyle(.plain)
                            .accessibilityLabel("Forward")

                            Button(action: { if let id = tabManager.currentTab { web.reload(in: id) } }) {
                                Image(systemName: "arrow.clockwise")
                                    .font(.system(size: 11, weight: .medium))
                                    .frame(width: 28, height: 28)
                                    .background(RoundedRectangle(cornerRadius: 6).fill(Color(white: 0.22).opacity(0.6)))
                            }
                            .buttonStyle(.plain)
                            .accessibilityLabel("Reload")
                        }

                        // Omnibox (search bar only)
                        HStack(spacing: 8) {
                            Image(systemName: "globe")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundStyle(.secondary)

                            TextField("Search or enter website name", text: $addressBarText)
                                .textFieldStyle(.plain)
                                .focused($addressBarFocused)
                                .onSubmit {
                                    searchSuggestions = []
                                    navigateFromAddressBar()
                                }
                                .onChange(of: addressBarText) { _, newValue in
                                    fetchSearchSuggestions(for: newValue)
                                }
                                .onChange(of: addressBarFocused) { _, focused in
                                    if !focused { searchSuggestions = [] }
                                }

                            Image(systemName: "magnifyingglass")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundStyle(.secondary)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 8)
                        .frame(maxWidth: .infinity)
                        .background(
                            RoundedRectangle(cornerRadius: 10)
                                .fill(Color(white: 0.18))
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(addressBarFocused ? Color.accentColor.opacity(0.8) : Color.clear, lineWidth: 2)
                        )
                        .animation(.easeInOut(duration: 0.15), value: addressBarFocused)
                        .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                            handleURLDrop(providers: providers) { url in
                                addressBarText = url.absoluteString
                                navigateToURL(url)
                            }
                        }

                        // Chat pill button (Chrome-style)
                        Button(action: toggleAIPanel) {
                            HStack(spacing: 4) {
                                Image(systemName: "bubble.left.and.bubble.right")
                                    .font(.system(size: 10, weight: .medium))
                                Text("Chat")
                                    .font(.system(size: 12, weight: .medium))
                            }
                            .padding(.horizontal, 10)
                            .padding(.vertical, 6)
                            .background(
                                RoundedRectangle(cornerRadius: 16)
                                    .fill(Color(white: 0.22).opacity(0.8))
                            )
                        }
                        .buttonStyle(.plain)
                        .accessibilityLabel("Toggle AI panel")
                    }
                    .padding(.horizontal, 6)
                    .padding(.vertical, 4)
                    .frame(height: addressBarHeight)
                    .frame(maxWidth: .infinity)
                    .padding(chromePadding)
                    .background(
                        tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) == nil
                            ? AnyView(Color(white: 0.13).clipShape(RoundedRectangle(cornerRadius: chromeCornerRadius)))
                            : AnyView(GlassBackground(material: .underWindowBackground, cornerRadius: chromeCornerRadius, padding: 0, shadowOpacity: 0.04))
                    )

                    if tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) != nil {
                        HairlineDivider(opacity: 0.15)
                    }

                    // Web content or start page
                    if let currentId = tabManager.currentTab {
                        let tabHasURL = (tabManager.tabURL[currentId] ?? nil) != nil
                        if !tabHasURL {
                            StartPageView(
                                entries: tabManager.navigationHistory,
                                onSelect: { url in
                                    _ = web.ensureWebView(for: currentId)
                                    web.setActiveTab(currentId)
                                    web.load(url: url, in: currentId)
                                    tabManager.navigate(tab: currentId, to: url)
                                    tabManager.addNavigation(title: url.host ?? url.absoluteString, url: url)
                                    addressBarText = url.absoluteString
                                    isFirstLoad = true
                                },
                                onOpenHistory: { showHistorySheet = true }
                            )
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                                handleURLDrop(providers: providers, action: { navigateToURL($0) })
                            }
                        } else {
                            ZStack {
                                WebViewContainer(webView: web.ensureWebView(for: currentId))
                                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                                    .id(currentId)
                                if isFirstLoad {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                                }
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                                handleURLDrop(providers: providers, action: { navigateToURL($0) })
                            }
                        }
                    } else {
                        Color(nsColor: .windowBackgroundColor)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .overlay(Text("No tab").foregroundColor(.secondary))
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .animation(.easeInOut(duration: 0.1), value: tabManager.currentTab)
                .overlay(alignment: .topLeading) {
                    // Search suggestions overlay (absolutely positioned, does not affect layout)
                    if addressBarFocused, !searchSuggestions.isEmpty {
                        VStack(spacing: 0) {
                            ForEach(Array(searchSuggestions.enumerated()), id: \.element) { _, suggestion in
                                Button(action: {
                                    addressBarText = suggestion
                                    searchSuggestions = []
                                    navigateFromAddressBar()
                                }) {
                                    HStack {
                                        Image(systemName: "magnifyingglass")
                                            .font(.system(size: 11))
                                            .foregroundStyle(.secondary)
                                            .frame(width: 20)
                                        Text(suggestion)
                                            .font(.system(size: 13))
                                            .foregroundStyle(.primary)
                                            .lineLimit(1)
                                            .frame(maxWidth: .infinity, alignment: .leading)
                                    }
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 8)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .contentShape(Rectangle())
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .background(Color(nsColor: .windowBackgroundColor))
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .shadow(color: .black.opacity(0.15), radius: 8)
                        .padding(.top, addressBarHeight + chromePadding + 6)
                        // Nav buttons: 28+28+28 = 84pt, spacing: 2+6 = 8pt, outer padding: 6+6 = 12pt
                        .padding(.leading, chromePadding + 6 + 84 + 8)
                        // Width matches search bar: available width minus nav section minus chat button and spacing
                        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topLeading)
                    }
                }

                if let currentId = tabManager.currentTab, tabsWithPanelOpen.contains(currentId) {
                    HStack(spacing: 0) {
                        PanelResizeHandle(panelWidth: $aiPanelWidth)

                        CommandSurfaceView(
                            isPresented: Binding(
                                get: { tabsWithPanelOpen.contains(currentId) },
                                set: { if !$0 { tabsWithPanelOpen.remove(currentId) } }
                            ),
                            messages: Binding(
                                get: { tabChatHistory[currentId] ?? [] },
                                set: { tabChatHistory[currentId] = $0 }
                            ),
                            webViewWrapper: web,
                            commandRouter: router,
                            gemini: gemini
                        ) { response in
                            pendingAssistantText = response.text
                            pendingAction = response.action
                            showActionConfirm = (response.action != nil)
                        }
                        .frame(width: aiPanelWidth)
                        .background(Color.black)
                    }
                    .transition(.opacity.combined(with: .move(edge: .trailing)))
                    .animation(.easeInOut(duration: 0.1), value: tabsWithPanelOpen.contains(currentId))
                }
            }
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                TabStripView(
                    tabManager: tabManager,
                    contentAreaColor: tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) == nil
                        ? Color(white: 0.13)
                        : Color(nsColor: .windowBackgroundColor),
                    onSwitch: { switchToTab($0) },
                    onClose: { closeTab($0) },
                    onNewTab: newTab,
                    onDropURLForNewTab: { newTabWithURL($0) }
                )
                .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
        .toolbarBackground(.visible, for: .windowToolbar)
        .alert("Confirm Action", isPresented: $showActionConfirm) {
            Button("Cancel", role: .cancel) { pendingAction = nil }
            Button("Execute") { executePendingAction() }
        } message: {
            if let action = pendingAction {
                let typeText = action.type.rawValue
                let payloadKeys = action.payload?.keys.sorted() ?? []
                let payloadSummary = payloadKeys.isEmpty ? "none" : payloadKeys.joined(separator: ", ")
                Text("Assistant: \(pendingAssistantText)\n\nAction: \(typeText)\nPayload keys: \(payloadSummary)")
            } else {
                Text("No action to execute.")
            }
        }
        .sheet(isPresented: $showHistorySheet) {
            HistoryView(
                entries: tabManager.navigationHistory,
                onSelect: { url in
                    showHistorySheet = false
                    if let id = tabManager.currentTab {
                        web.load(url: url, in: id)
                        tabManager.navigate(tab: id, to: url)
                        addressBarText = url.absoluteString
                    }
                },
                onDismiss: { showHistorySheet = false }
            )
        }
        .onAppear {
            if tabManager.currentTab == nil {
                _ = tabManager.newTab(url: nil)
                if let id = tabManager.currentTab {
                    web.setActiveTab(id)
                    addressBarText = ""
                }
            }
            eventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                let key = event.charactersIgnoringModifiers ?? ""
                if event.modifierFlags.contains(.command) {
                    if key == "e" {
                        DispatchQueue.main.async {
                            guard let id = tabManager.currentTab else { return }
                            if tabsWithPanelOpen.contains(id) {
                                tabsWithPanelOpen.remove(id)
                            } else {
                                tabsWithPanelOpen.insert(id)
                            }
                        }
                        return nil
                    }
                    if key == "t" {
                        DispatchQueue.main.async { newTab() }
                        return nil
                    }
                    if key == "w" {
                        DispatchQueue.main.async { closeCurrentTab() }
                        return nil
                    }
                    if key == "y" {
                        DispatchQueue.main.async { showHistorySheet = true }
                        return nil
                    }
                    if key == "l" {
                        DispatchQueue.main.async { addressBarFocused = true }
                        return nil
                    }
                }
                if event.keyCode == 53 {
                    // Escape: restore address bar to live URL and stop editing
                    DispatchQueue.main.async { restoreAddressBarOnEscape = true }
                    return nil
                }
                return event
            }
        }
        .onChange(of: tabManager.currentTab) { _, newId in
            if let id = newId {
                web.setActiveTab(id)
                syncAddressBarFromCurrentTab()
            } else {
                addressBarText = ""
            }
        }
        .onChange(of: web.currentURL) { _, _ in
            syncAddressBarFromCurrentTab()
            if web.currentURL != nil { isFirstLoad = false }
        }
        .onChange(of: restoreAddressBarOnEscape) { _, new in
            if new {
                syncAddressBarFromCurrentTab()
                addressBarFocused = false
                restoreAddressBarOnEscape = false
            }
        }
        .onDisappear {
            if let m = eventMonitor {
                NSEvent.removeMonitor(m)
                eventMonitor = nil
            }
        }
    }

    private func syncAddressBarFromCurrentTab() {
        if let id = tabManager.currentTab {
            if let url = web.currentURL {
                addressBarText = url.absoluteString
                tabManager.navigate(tab: id, to: url)
            } else if let url = tabManager.tabURL[id] ?? nil {
                addressBarText = url.absoluteString
            } else {
                addressBarText = ""
            }
        } else {
            addressBarText = ""
        }
    }

    /// Fetches search suggestions (debounced 25ms). Uses Google Suggest.
    private func fetchSearchSuggestions(for query: String) {
        suggestionDebounceTask?.cancel()
        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, trimmed.count >= 2 else {
            searchSuggestions = []
            return
        }
        let task = DispatchWorkItem {
            guard let encoded = trimmed.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
                  let url = URL(string: "https://suggestqueries.google.com/complete/search?client=firefox&q=\(encoded)") else { return }
            URLSession.shared.dataTask(with: url) { data, _, _ in
                guard let data = data,
                      var raw = String(data: data, encoding: .utf8) else {
                    DispatchQueue.main.async { searchSuggestions = [] }
                    return
                }
                if raw.hasPrefix("window."), let start = raw.firstIndex(of: "["), let end = raw.lastIndex(of: "]") {
                    raw = String(raw[start...end])
                }
                guard let jsonData = raw.data(using: .utf8),
                      let json = try? JSONSerialization.jsonObject(with: jsonData) as? [Any],
                      json.count >= 2,
                      let rawSuggestions = json[1] as? [Any] else {
                    DispatchQueue.main.async { searchSuggestions = [] }
                    return
                }
                let phrases = rawSuggestions.compactMap { item -> String? in
                    if let s = item as? String { return s }
                    if let arr = item as? [Any], let first = arr.first as? String { return first }
                    return nil
                }
                DispatchQueue.main.async {
                    searchSuggestions = phrases.prefix(8).map { $0 }
                }
            }.resume()
        }
        suggestionDebounceTask = task
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.025, execute: task)
    }

    /// Omnibox parsing: URL, domain, or search query.
    private func resolveToURL(_ input: String) -> URL? {
        let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }

        if trimmed.lowercased().hasPrefix("http://") || trimmed.lowercased().hasPrefix("https://") {
            return URL(string: trimmed)
        }

        if !trimmed.contains(" "), trimmed.contains(".") {
            return URL(string: "https://" + trimmed)
        }

        let encoded = trimmed.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? trimmed
        return URL(string: "https://www.google.com/search?q=" + encoded)
    }

    /// Navigate from address bar (Enter/Return). Uses omnibox rules; no navigation until Enter.
    private func navigateFromAddressBar() {
        guard let url = resolveToURL(addressBarText) else { return }
        navigateToURL(url)
    }

    /// Navigate current tab (or create one) to the given URL. Used by address bar and drag-drop.
    private func navigateToURL(_ url: URL) {
        let title = url.host ?? url.absoluteString
        if tabManager.currentTab == nil {
            let id = tabManager.newTab(url: url)
            _ = web.ensureWebView(for: id)
            web.setActiveTab(id)
            web.load(url: url, in: id)
        } else if let id = tabManager.currentTab {
            tabManager.navigate(tab: id, to: url)
            web.load(url: url, in: id)
        }
        tabManager.addNavigation(title: title, url: url)
        addressBarText = url.absoluteString
    }

    /// Creates a new tab and navigates to the given URL. Used by drag-drop on tab strip.
    private func newTabWithURL(_ url: URL) {
        let id = tabManager.newTab(url: url)
        _ = web.ensureWebView(for: id)
        web.setActiveTab(id)
        web.load(url: url, in: id)
        tabManager.navigate(tab: id, to: url)
        tabManager.addNavigation(title: url.host ?? url.absoluteString, url: url)
        addressBarText = url.absoluteString
    }

    /// Extracts URL from drop providers (links, file URLs, plain text). Calls action on main queue when URL is found.
    private func handleURLDrop(providers: [NSItemProvider], action: @escaping (URL) -> Void) -> Bool {
        guard let provider = providers.first else { return false }
        if provider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url, (u.scheme == "http" || u.scheme == "https" || u.scheme == "file") {
                    DispatchQueue.main.async { action(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.fileURL.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url {
                    DispatchQueue.main.async { action(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
            _ = provider.loadObject(ofClass: String.self) { str, _ in
                if let s = str?.trimmingCharacters(in: .whitespacesAndNewlines),
                   let u = URL(string: s),
                   u.scheme == "http" || u.scheme == "https" {
                    DispatchQueue.main.async { action(u) }
                }
            }
        }
        return true
    }

    private func toggleAIPanel() {
        guard let id = tabManager.currentTab else { return }
        if tabsWithPanelOpen.contains(id) {
            tabsWithPanelOpen.remove(id)
        } else {
            tabsWithPanelOpen.insert(id)
        }
    }

    private func newTab() {
        let id = tabManager.newTab(url: nil)
        _ = web.ensureWebView(for: id)
        web.setActiveTab(id)
        addressBarText = ""
        addressBarFocused = true
    }

    private func closeCurrentTab() {
        guard let id = tabManager.currentTab else { return }
        closeTab(id)
    }

    private func closeTab(_ id: UUID) {
        web.removeWebView(for: id)
        tabsWithPanelOpen.remove(id)
        tabChatHistory.removeValue(forKey: id)
        tabManager.closeTab(id)
        if tabManager.currentTab == nil {
            newTab()
        } else if let newCurrent = tabManager.currentTab {
            web.setActiveTab(newCurrent)
            syncAddressBarFromCurrentTab()
        }
    }

    private func switchToTab(_ id: UUID) {
        tabManager.switchToTab(id)
        web.setActiveTab(id)
        syncAddressBarFromCurrentTab()
    }


    private func executePendingAction() {
        guard let action = pendingAction else { return }

        let tabToClose: UUID?
        if action.type == .close_tab, action.payload?["index"] == nil {
            tabToClose = tabManager.currentTab
        } else {
            tabToClose = nil
        }

        let result = router.execute(action: action, tabManager: tabManager)
        switch result {
        case .success:
            if let id = tabToClose {
                web.removeWebView(for: id)
            }
            if action.type == .new_tab || action.type == .navigate,
               let urlString = action.payload?["url"],
               let url = URL(string: urlString.contains("://") ? urlString : "https://" + urlString) {
                if action.type == .new_tab, let id = tabManager.currentTab {
                    web.setActiveTab(id)
                    web.load(url: url, in: id)
                    tabManager.navigate(tab: id, to: url)
                    addressBarText = url.absoluteString
                } else if action.type == .navigate, let id = tabManager.currentTab {
                    web.load(url: url, in: id)
                    tabManager.navigateCurrentTab(to: url)
                    addressBarText = url.absoluteString
                }
            }
        case .failure:
            break
        }

        pendingAction = nil
    }
}

// MARK: - Start page (new tab / no URL)

private struct StartPageView: View {
    let entries: [HistoryEntry]
    let onSelect: (URL) -> Void
    let onOpenHistory: () -> Void

    private static let favorites: [(String, String, String)] = [
        ("Google", "https://www.google.com", "magnifyingglass"),
        ("Wikipedia", "https://www.wikipedia.org", "book.closed"),
        ("GitHub", "https://github.com", "chevron.left.forwardslash.chevron.right"),
        ("YouTube", "https://www.youtube.com", "play.rectangle"),
    ]

    private let pageBg = Color(white: 0.11)
    private let sectionTitle = Color.white.opacity(0.9)
    private let muted = Color.white.opacity(0.5)

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 32) {
                // Favorites — large icon tiles
                VStack(alignment: .leading, spacing: 14) {
                    Text("Favorites")
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(sectionTitle)

                    HStack(spacing: 16) {
                        ForEach(Self.favorites, id: \.1) { title, urlString, iconName in
                            if let url = URL(string: urlString) {
                                FavoriteTile(
                                    title: title,
                                    iconName: iconName,
                                    action: { onSelect(url) }
                                )
                            }
                        }
                    }
                }

                // Recent — grid of cards (when history exists)
                if !entries.isEmpty {
                    VStack(alignment: .leading, spacing: 14) {
                        HStack {
                            Text("Recent")
                                .font(.system(size: 15, weight: .semibold))
                                .foregroundColor(sectionTitle)
                            Spacer()
                            Button("All history", action: onOpenHistory)
                                .font(.system(size: 12))
                                .foregroundColor(muted)
                                .buttonStyle(.plain)
                        }

                        LazyVGrid(columns: [
                            GridItem(.adaptive(minimum: 200, maximum: 280), spacing: 12),
                        ], spacing: 12) {
                            ForEach(entries.prefix(12)) { entry in
                                RecentCard(entry: entry) { onSelect(entry.url) }
                            }
                        }
                    }
                }
            }
            .padding(28)
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .background(pageBg)
    }
}

private struct FavoriteTile: View {
    let title: String
    let iconName: String
    let action: () -> Void

    @State private var isHovered = false

    var body: some View {
        Button(action: action) {
            VStack(spacing: 10) {
                Image(systemName: iconName)
                    .font(.system(size: 24))
                    .foregroundColor(.white.opacity(0.9))
                    .frame(width: 56, height: 56)
                    .background(Color.white.opacity(isHovered ? 0.18 : 0.12))
                    .clipShape(RoundedRectangle(cornerRadius: 14))
                Text(title)
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.white.opacity(0.85))
                    .lineLimit(1)
            }
            .frame(width: 88)
            .padding(10)
            .background(Color.white.opacity(isHovered ? 0.08 : 0.04))
            .clipShape(RoundedRectangle(cornerRadius: 16))
        }
        .buttonStyle(.plain)
        .onHover { isHovered = $0 }
    }
}

private struct RecentCard: View {
    let entry: HistoryEntry
    let action: () -> Void

    @State private var isHovered = false

    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                Image(systemName: "globe")
                    .font(.system(size: 14))
                    .foregroundColor(.white.opacity(0.5))
                    .frame(width: 28, height: 28)
                    .background(Color.white.opacity(0.08))
                    .clipShape(RoundedRectangle(cornerRadius: 6))

                VStack(alignment: .leading, spacing: 4) {
                    Text(entry.title)
                        .font(.system(size: 13, weight: .medium))
                        .foregroundColor(.white.opacity(0.9))
                        .lineLimit(1)
                    Text(entry.url.host ?? entry.url.absoluteString)
                        .font(.system(size: 11))
                        .foregroundColor(.white.opacity(0.45))
                        .lineLimit(1)
                }
                .frame(maxWidth: .infinity, alignment: .leading)

                Image(systemName: "arrow.right")
                    .font(.system(size: 10, weight: .medium))
                    .foregroundColor(.white.opacity(0.3))
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 12)
            .background(Color.white.opacity(isHovered ? 0.12 : 0.06))
            .clipShape(RoundedRectangle(cornerRadius: 12))
        }
        .buttonStyle(.plain)
        .onHover { isHovered = $0 }
    }
}

// MARK: - History sheet (Cmd+Y)

private struct HistoryView: View {
    let entries: [HistoryEntry]
    let onSelect: (URL) -> Void
    let onDismiss: () -> Void

    private static let dateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.dateStyle = .short
        f.timeStyle = .short
        return f
    }()

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Text("History")
                    .font(.headline)
                Spacer()
                Button("Done", action: onDismiss)
                    .keyboardShortcut(.escape, modifiers: [])
            }
            .padding()

            Divider()

            if entries.isEmpty {
                Text("No history yet")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                List(entries) { entry in
                    Button {
                        onSelect(entry.url)
                    } label: {
                        VStack(alignment: .leading, spacing: 2) {
                            Text(entry.title)
                                .lineLimit(1)
                                .font(.system(size: 13, weight: .medium))
                            Text(entry.url.absoluteString)
                                .lineLimit(1)
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text(Self.dateFormatter.string(from: entry.date))
                                .font(.caption2)
                                .foregroundColor(.secondary.opacity(0.8))
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.vertical, 4)
                    }
                    .buttonStyle(.plain)
                }
                .listStyle(.plain)
            }
        }
        .frame(minWidth: 400, minHeight: 300)
    }
}

private struct PanelResizeHandle: View {
    @Binding var panelWidth: CGFloat

    private let minWidth: CGFloat = 280
    private let maxWidth: CGFloat = 700
    @State private var dragStartWidth: CGFloat = 0

    var body: some View {
        Rectangle()
            .fill(Color.clear)
            .frame(width: 6)
            .contentShape(Rectangle())
            .onHover { hovering in
                if hovering {
                    NSCursor.resizeLeftRight.push()
                } else {
                    NSCursor.pop()
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        if dragStartWidth == 0 {
                            dragStartWidth = panelWidth
                        }
                        let newWidth = dragStartWidth - value.translation.width
                        panelWidth = min(maxWidth, max(minWidth, newWidth))
                    }
                    .onEnded { _ in
                        dragStartWidth = 0
                    }
            )
    }
}

// MARK: - Tab strip (titlebar, leading-aligned)

private struct TabStripView: View {
    @ObservedObject var tabManager: TabManager
    let contentAreaColor: Color
    let onSwitch: (UUID) -> Void
    let onClose: (UUID) -> Void
    let onNewTab: () -> Void
    let onDropURLForNewTab: (URL) -> Void

    private let rowHeight: CGFloat = 30

    var body: some View {
        GeometryReader { geo in
            let count = tabManager.tabCount()
            let tabWidth: CGFloat = count > 0 ? max(90, (geo.size.width - 59) / CGFloat(count)) : 0

            HStack(spacing: 0) {
                ForEach(Array(tabManager.tabOrder.enumerated()), id: \.element) { index, tabId in
                    TabPill(
                        tabId: tabId,
                        index: index + 1,
                        url: tabManager.tabURL[tabId] ?? nil,
                        isActive: tabManager.currentTab == tabId,
                        contentAreaColor: contentAreaColor,
                        onSelect: { onSwitch(tabId) },
                        onClose: { onClose(tabId) }
                    )
                    .frame(width: tabWidth, height: rowHeight)
                    .id(tabId)
                }

                Button(action: onNewTab) {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(.secondary)
                        .frame(width: 32, height: rowHeight - 4)
                        .contentShape(Rectangle())
                        .background(RoundedRectangle(cornerRadius: 6).fill(Color(white: 0.22).opacity(0.6)))
                }
                .buttonStyle(.plain)
                .accessibilityLabel("New tab")
                .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                    urlDropHandler(providers: providers)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(height: rowHeight)
        .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
            urlDropHandler(providers: providers)
        }
    }

    private func urlDropHandler(providers: [NSItemProvider]) -> Bool {
        guard let provider = providers.first else { return false }
        if provider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url, (u.scheme == "http" || u.scheme == "https" || u.scheme == "file") {
                    DispatchQueue.main.async { onDropURLForNewTab(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.fileURL.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url {
                    DispatchQueue.main.async { onDropURLForNewTab(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
            _ = provider.loadObject(ofClass: String.self) { str, _ in
                if let s = str?.trimmingCharacters(in: .whitespacesAndNewlines),
                   let u = URL(string: s),
                   u.scheme == "http" || u.scheme == "https" {
                    DispatchQueue.main.async { onDropURLForNewTab(u) }
                }
            }
        }
        return true
    }
}

private struct TabPill: View {
    let tabId: UUID
    let index: Int
    let url: URL?
    let isActive: Bool
    let contentAreaColor: Color
    let onSelect: () -> Void
    let onClose: () -> Void

    @State private var isHovered = false

    private var title: String {
        url?.host ?? url?.absoluteString ?? "New Tab"
    }

    private var leadingIcon: String {
        url == nil ? "globe" : "doc.text"
    }

    var body: some View {
        HStack(spacing: 0) {
            Button(action: onSelect) {
                HStack(spacing: 6) {
                    Image(systemName: leadingIcon)
                        .font(.system(size: 11, weight: .medium))
                        .foregroundStyle(isActive ? .primary : .secondary)
                        .frame(width: 14, alignment: .center)

                    Text(title)
                        .lineLimit(1)
                        .truncationMode(.tail)
                        .font(.system(size: 12, weight: .medium))
                        .foregroundStyle(isActive ? .primary : .secondary)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                .padding(.leading, 8)
                .padding(.trailing, 4)
                .padding(.vertical, 4)
                .contentShape(Rectangle())
                .frame(maxWidth: .infinity)
            }
            .buttonStyle(.plain)

            Button(action: onClose) {
                Image(systemName: "xmark")
                    .font(.system(size: 9, weight: .semibold))
                    .foregroundColor(.secondary)
                    .frame(width: 20, height: 20)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            .opacity(isHovered || isActive ? 1 : 0)
            .allowsHitTesting(isHovered || isActive)
        }
        .onHover { hovering in
            isHovered = hovering
        }
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(isActive
                    ? contentAreaColor
                    : Color(white: 0.22).opacity(isHovered ? 0.9 : 0.6))
        )
        .animation(.easeInOut(duration: 0.15), value: isHovered)
        .animation(.easeInOut(duration: 0.15), value: isActive)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Tab \(index): \(title)")
        .accessibilityAddTraits(isActive ? [.isButton, .isSelected] : .isButton)
    }
}

struct WebViewContainer: NSViewRepresentable {
    let webView: WKWebView

    func makeNSView(context: Context) -> WKWebView { webView }
    func updateNSView(_ nsView: WKWebView, context: Context) {}
}

#Preview {
    BrowserShellView()
}
