// Luma MVP - autogenerated by Cursor
import SwiftUI
import WebKit
import AppKit
import Combine
import UniformTypeIdentifiers

/// Holds address bar suggestion selection for keyboard (Up/Down/Enter) and autofill.
private final class AddressBarKeyState: ObservableObject {
    @Published var selectedIndex: Int = 0
    @Published var totalCount: Int = 0
    @Published var visible: Bool = false
    @Published var submitSelection: Bool = false
}

/// Minimal browser shell hosting WKWebViews via WebViewWrapper and TabManager.
///
/// Per SRS: WebKit-only renderer, minimal tab UI, address bar.
/// Omnibox: accepts full URL, domain, or search query.
/// Per SECURITY.md: No JS message handlers, no HTML scraping.
struct BrowserShellView: View {
    @StateObject private var tabManager = TabManager()
    @StateObject private var web: WebViewWrapper = {
        let wrapper = WebViewWrapper()
        return wrapper
    }()
    @State private var addressBarText: String = ""
    @State private var tabsWithPanelOpen: Set<UUID> = []
    @State private var tabChatHistory: [UUID: [ChatMessage]] = [:]
    @State private var tabAIChatMessages: [UUID: [ChatMessage]] = [:]
    @State private var aiPanelWidth: CGFloat = 380
    @State private var shouldResetPanelWidth: Bool = false
    @State private var isDraggingDivider: Bool = false
    @State private var eventMonitor: Any?
    @State private var pendingAction: BrowserAction? = nil
    @State private var pendingAssistantText: String = ""
    @State private var showActionConfirm: Bool = false
    @State private var restoreAddressBarOnEscape: Bool = false
    @State private var isFirstLoad: Bool = true
    @FocusState private var addressBarFocused: Bool
    @State private var searchSuggestions: [String] = []
    @State private var historySuggestions: [(display: String, url: URL)] = []
    @StateObject private var addressBarKeyState = AddressBarKeyState()
    @State private var suggestionDebounceTask: DispatchWorkItem?
    @State private var historyDebounceTask: DispatchWorkItem?
    @State private var showDownloadsHub: Bool = false
    @State private var showGoogleAPIKeyHelpSheet: Bool = false
    @State private var showBrowserFindBar: Bool = false
    @State private var browserFindQuery: String = ""
    @ObservedObject private var downloadManager = DownloadManager.shared
    @State private var downloadIconScale: CGFloat = 1

    private let router = CommandRouter()
    private let gemini = GeminiClient(apiKeyProvider: { KeychainManager.shared.fetchGeminiKey() })
    private let ollama = OllamaClient()

    // Layout constants
    private let tabStripHeight: CGFloat = 38
    private let addressBarHeight: CGFloat = 44
    private let chromeCornerRadius: CGFloat = 14
    private let chromePadding: CGFloat = 4

    /// DIA-style: unified chrome color (tabs + address bar + content). Start page = dark; web page = page theme or default.
    private var chromeColor: Color {
        let hasURL = tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) != nil
        if !hasURL { return Color(white: 0.13) }
        if let theme = web.pageThemeForActiveTab { return theme.color }
        return Color(nsColor: .windowBackgroundColor)
    }

    /// true = dark background → use light text; false = light background → use dark text.
    private var chromeTextIsLight: Bool {
        let hasURL = tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) != nil
        if !hasURL { return true }
        return web.pageThemeForActiveTab?.isDark ?? false
    }

    private var chromeText: Color { chromeTextIsLight ? Color.white : Color(white: 0.15) }
    private var chromeTextMuted: Color { chromeTextIsLight ? Color.white.opacity(0.7) : Color(white: 0.15).opacity(0.7) }

    var body: some View {
        // Compute tab strip visibility once
        let currentURL = tabManager.currentTab.flatMap { tabManager.tabURL[$0] ?? nil }
        let isStartPage = (currentURL == nil || currentURL?.absoluteString == "about:blank")
        let shouldShowTabStrip = tabManager.tabCount() > 1 || !isStartPage
        
        return ZStack {
            Color(nsColor: .windowBackgroundColor)
                .ignoresSafeArea()

            // Configures the window titlebar to be tall enough to hold tabs.
            // This is the key: it sets window.titlebarHeight so the traffic-light
            // row is as tall as our tab strip (or default height when tabs hidden).
            TitlebarConfigurator(tabStripHeight: shouldShowTabStrip ? tabStripHeight : 0)

            GeometryReader { geometry in
                HStack(spacing: 0) {
                    // Left: main browser content
                    VStack(spacing: 0) {

                    // ─── Tab strip (toolbar stays dark; active tab uses chromeColor) ───
                    // Hide tab strip on start page when there's only one tab
                    if shouldShowTabStrip {
                        TabStripView(
                            tabManager: tabManager,
                            faviconURLByTab: web.faviconURLByTab,
                            contentAreaColor: chromeColor,
                            chromeTextIsLight: chromeTextIsLight,
                            onSwitch: { switchToTab($0) },
                            onClose: { closeTab($0) },
                            onNewTab: newTab,
                            onDropURLForNewTab: { newTabWithURL($0) },
                            onReorder: { tabManager.moveTab(from: $0, to: $1) }
                        )
                        .frame(height: tabStripHeight)
                        .padding(.leading, 78)   // clear traffic lights
                        .padding(.trailing, 8)
                        .padding(.top, -(tabStripHeight - 6)) // pull up into titlebar
                        .background(Color(white: 0.12))   // toolbar: dark strip (traffic lights + inactive area)
                        .transition(.move(edge: .top).combined(with: .opacity))
                    }

                    // ─── Address bar row (hidden on start page and AI chat; single centered bar is the search there) ───
                    if let cid = tabManager.currentTab,
                       let u = tabManager.tabURL[cid] ?? nil,
                       u.absoluteString != "about:blank",
                       !(u.scheme == "luma" && u.host == "ai") {
                        HStack(spacing: 6) {
                            // Nav buttons (greyed out when nothing to go back/forward to)
                            HStack(spacing: 2) {
                                Button(action: { if let id = tabManager.currentTab { web.goBack(in: id) } }) {
                                    Image(systemName: "chevron.left")
                                        .font(.system(size: 11, weight: .medium))
                                        .foregroundColor(web.canGoBackForActiveTab ? chromeText : chromeText.opacity(0.35))
                                        .frame(width: 28, height: 28)
                                        .background(RoundedRectangle(cornerRadius: 6).fill((web.canGoBackForActiveTab ? chromeText : chromeText.opacity(0.35)).opacity(0.15)))
                                }
                                .buttonStyle(.plain)
                                .disabled(!web.canGoBackForActiveTab)
                                .accessibilityLabel("Back")

                                Button(action: { if let id = tabManager.currentTab { web.goForward(in: id) } }) {
                                    Image(systemName: "chevron.right")
                                        .font(.system(size: 11, weight: .medium))
                                        .foregroundColor(web.canGoForwardForActiveTab ? chromeText : chromeText.opacity(0.35))
                                        .frame(width: 28, height: 28)
                                        .background(RoundedRectangle(cornerRadius: 6).fill((web.canGoForwardForActiveTab ? chromeText : chromeText.opacity(0.35)).opacity(0.15)))
                                }
                                .buttonStyle(.plain)
                                .disabled(!web.canGoForwardForActiveTab)
                                .accessibilityLabel("Forward")

                                Button(action: { if let id = tabManager.currentTab { web.reload(in: id) } }) {
                                    Image(systemName: "arrow.clockwise")
                                        .font(.system(size: 11, weight: .medium))
                                        .foregroundColor(chromeText)
                                        .frame(width: 28, height: 28)
                                        .background(RoundedRectangle(cornerRadius: 6).fill(chromeText.opacity(0.15)))
                                }
                                .buttonStyle(.plain)
                                .accessibilityLabel("Reload")
                            }

                            // Omnibox (unified look: subtle overlay on chrome)
                            HStack(spacing: 8) {
                                Image(systemName: "globe")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundStyle(chromeTextMuted)

                                TextField("Search or enter website name", text: $addressBarText)
                                    .textFieldStyle(.plain)
                                    .foregroundColor(chromeText)
                                    .focused($addressBarFocused)
                                    .onSubmit {
                                        applyAddressBarSubmit()
                                    }
                                    .onChange(of: addressBarText) { _, newValue in
                                        fetchHistorySuggestions(for: newValue)
                                        fetchSearchSuggestions(for: newValue)
                                    }
                                    .onChange(of: addressBarFocused) { _, focused in
                                        if !focused {
                                            searchSuggestions = []
                                            historySuggestions = []
                                            addressBarKeyState.visible = false
                                        }
                                    }
                                    .onTapGesture {
                                        selectAllAddressBarText()
                                    }

                                Image(systemName: "magnifyingglass")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundStyle(chromeTextMuted)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 8)
                            .frame(maxWidth: .infinity)
                            .background(
                                RoundedRectangle(cornerRadius: 10)
                                    .fill(chromeText.opacity(0.12))
                            )
                            .overlay(
                                RoundedRectangle(cornerRadius: 10)
                                    .stroke(addressBarFocused ? Color.accentColor.opacity(0.8) : Color.clear, lineWidth: 2)
                            )
                            .animation(.easeInOut(duration: 0.1), value: addressBarFocused)
                            .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                                handleURLDrop(providers: providers) { url in
                                    addressBarText = url.absoluteString
                                    navigateToURL(url)
                                }
                            }

                            // Chat pill
                            Button(action: toggleAIPanel) {
                                HStack(spacing: 4) {
                                    Image(systemName: "bubble.left.and.bubble.right")
                                        .font(.system(size: 10, weight: .medium))
                                    Text("Chat")
                                        .font(.system(size: 12, weight: .medium))
                                }
                                .foregroundColor(chromeText)
                                .padding(.horizontal, 10)
                                .padding(.vertical, 6)
                                .background(
                                    RoundedRectangle(cornerRadius: 16)
                                        .fill(chromeText.opacity(0.15))
                                )
                            }
                            .buttonStyle(.plain)
                            .accessibilityLabel("Toggle AI panel")

                            // Downloads hub (heartbeat on new download + count badge)
                            Button(action: { showDownloadsHub = true }) {
                                ZStack(alignment: .topTrailing) {
                                    Image(systemName: "arrow.down.circle")
                                        .font(.system(size: 16, weight: .medium))
                                        .foregroundColor(chromeText.opacity(0.9))
                                        .frame(width: 28, height: 28)
                                        .contentShape(Rectangle())
                                        .scaleEffect(downloadIconScale)
                                    if !downloadManager.recentDownloads.isEmpty {
                                        Text(downloadManager.recentDownloads.count > 99 ? "99+" : "\(downloadManager.recentDownloads.count)")
                                            .font(.system(size: 10, weight: .semibold))
                                            .foregroundColor(.white)
                                            .padding(.horizontal, 5)
                                            .padding(.vertical, 2)
                                            .background(Capsule().fill(Color.accentColor))
                                            .offset(x: 6, y: -6)
                                    }
                                }
                            }
                            .buttonStyle(.plain)
                            .accessibilityLabel("Downloads")
                            .onChange(of: downloadManager.recentDownloads.count) { oldCount, newCount in
                                if newCount > oldCount { runDownloadsHeartbeat() }
                            }
                        }
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .frame(height: addressBarHeight)
                        .frame(maxWidth: .infinity)
                        .background(chromeColor)
                        .animation(.easeInOut(duration: 0.06), value: chromeColor)
                    }

                    // ─── Web content or start page ───────────────────────────
                    if let currentId = tabManager.currentTab {
                        let currentURL = tabManager.tabURL[currentId] ?? nil
                        let isStartPage = (currentURL == nil || currentURL?.absoluteString == "about:blank")
                        let isAIChat = currentURL?.scheme == "luma" && currentURL?.host == "ai"
                        
                        if isStartPage || isAIChat {
                            SmartSearchView(
                                gemini: gemini,
                                ollama: ollama,
                                tabManager: tabManager,
                                webViewWrapper: web,
                                tabId: currentId,
                                messages: aiChatMessagesBinding(for: currentId),
                                onNavigate: { url in navigateToURL(url) }
                            )
                            .id(currentId)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                        } else if currentURL?.scheme == "luma", currentURL?.host == "history" {
                            // History page (always in its own tab)
                            // Special luma://history page
                            HistoryPageView(onSelectURL: { url in
                                navigateToURL(url)
                            })
                                .frame(maxWidth: .infinity, maxHeight: .infinity)
                        } else {
                            ZStack(alignment: .top) {
                                WebViewContainer(webView: web.ensureWebView(for: currentId))
                                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                                    .id(currentId)
                                if isFirstLoad {
                                    ProgressView()
                                        .scaleEffect(0.8)
                                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                                        .onAppear {
                                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                                                isFirstLoad = false
                                            }
                                        }
                                }
                                if web.googleSuspiciousErrorDetected, currentURL?.host?.contains("aistudio.google.com") == true {
                                    GoogleSuspiciousErrorBanner(
                                        onDismiss: { web.clearGoogleSuspiciousErrorBanner() },
                                        onLearnMore: { showGoogleAPIKeyHelpSheet = true }
                                    )
                                    .padding(.horizontal, 12)
                                    .padding(.top, 12)
                                    .transition(.move(edge: .top).combined(with: .opacity))
                                }
                                if showBrowserFindBar {
                                    BrowserFindBar(
                                        query: $browserFindQuery,
                                        onFind: { query in
                                            if let id = tabManager.currentTab {
                                                web.findInPage(query: query, in: id)
                                            }
                                        },
                                        onNext: {
                                            if let id = tabManager.currentTab {
                                                web.findNext(in: id)
                                            }
                                        },
                                        onPrevious: {
                                            if let id = tabManager.currentTab {
                                                web.findPrevious(in: id)
                                            }
                                        },
                                        onDismiss: {
                                            showBrowserFindBar = false
                                            browserFindQuery = ""
                                            if let id = tabManager.currentTab {
                                                web.clearFind(in: id)
                                            }
                                        }
                                    )
                                    .transition(.move(edge: .top).combined(with: .opacity))
                                }
                            }
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                                handleURLDrop(providers: providers, action: { navigateToURL($0) })
                            }
                            .sheet(isPresented: $showGoogleAPIKeyHelpSheet) {
                                GoogleAPIKeyHelpView()
                            }
                        }
                    } else {
                        Color(nsColor: .windowBackgroundColor)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .overlay(Text("No tab").foregroundColor(.secondary))
                    }
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .animation(.easeInOut(duration: 0.08), value: tabManager.currentTab)
                .animation(.easeInOut(duration: 0.06), value: shouldShowTabStrip)
                .animation(.easeInOut(duration: 0.06), value: tabManager.tabCount())
                .overlay(alignment: .topLeading) {
                    // Address bar suggestions: history (URL/title) first, then search; show when any suggestion exists
                    let hasSuggestions = !historySuggestions.isEmpty || !searchSuggestions.isEmpty
                    if tabManager.currentTab.flatMap({ tabManager.tabURL[$0] ?? nil }) != nil,
                       (tabManager.currentTab.flatMap { tabManager.tabURL[$0] ?? nil }?.absoluteString ?? "") != "about:blank",
                       addressBarFocused,
                       !addressBarText.trimmingCharacters(in: .whitespaces).isEmpty,
                       hasSuggestions {
                        AddressBarSuggestionsList(
                            historyItems: historySuggestions,
                            searchPhrases: Array(searchSuggestions.prefix(5)),
                            selectedIndex: addressBarKeyState.selectedIndex,
                            onSelectHistory: { url in
                                searchSuggestions = []
                                historySuggestions = []
                                addressBarKeyState.visible = false
                                navigateToURL(url)
                            },
                            onSelectSearch: { phrase in
                                addressBarText = phrase
                                searchSuggestions = []
                                historySuggestions = []
                                addressBarKeyState.visible = false
                                navigateFromAddressBar()
                            }
                        )
                        .background(Color(nsColor: .windowBackgroundColor))
                        .clipShape(RoundedRectangle(cornerRadius: 8))
                        .shadow(color: .black.opacity(0.15), radius: 8)
                        .padding(.top, addressBarHeight + chromePadding + 6)
                        .padding(.leading, chromePadding + 6 + 84 + 8)
                        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .topLeading)
                        .onAppear {
                            addressBarKeyState.visible = true
                            addressBarKeyState.totalCount = historySuggestions.count + searchSuggestions.count
                            addressBarKeyState.selectedIndex = 0
                        }
                        .onDisappear { addressBarKeyState.visible = false }
                    }
                }

                    // ─── AI side panel (hidden on start page and AI chat) ────────
                    if let currentId = tabManager.currentTab, tabsWithPanelOpen.contains(currentId), !isCurrentTabStartOrAIChat {
                        HStack(spacing: 0) {
                            PanelResizeHandle(panelWidth: $aiPanelWidth, windowWidth: geometry.size.width, isDragging: $isDraggingDivider)

                            CommandSurfaceView(
                                isPresented: Binding(
                                    get: { tabsWithPanelOpen.contains(currentId) },
                                    set: { if !$0 { tabsWithPanelOpen.remove(currentId) } }
                                ),
                                messages: Binding(
                                    get: { tabChatHistory[currentId] ?? [] },
                                    set: { 
                                        tabChatHistory[currentId] = $0
                                        saveChatHistory()
                                    }
                                ),
                                webViewWrapper: web,
                                commandRouter: router,
                                gemini: gemini,
                                ollama: ollama,
                                tabId: currentId
                            ) { response in
                                pendingAssistantText = response.text
                                pendingAction = response.action
                                showActionConfirm = (response.action != nil)
                            }
                            .frame(width: aiPanelWidth - chromePadding)
                            .clipShape(RoundedRectangle(cornerRadius: chromeCornerRadius))
                            .padding(.trailing, chromePadding)
                            .padding(.vertical, chromePadding)
                        }
                        .transition(.asymmetric(
                            insertion: .move(edge: .trailing).combined(with: .opacity),
                            removal: .move(edge: .trailing).combined(with: .opacity)
                        ))
                        .animation(isDraggingDivider ? nil : .spring(response: 0.35, dampingFraction: 0.85), value: tabsWithPanelOpen.contains(currentId))
                        .animation(isDraggingDivider ? nil : .spring(response: 0.3, dampingFraction: 0.9), value: aiPanelWidth)
                        .onAppear {
                            if shouldResetPanelWidth {
                                // Set to 1/3 of total width
                                aiPanelWidth = geometry.size.width / 3
                                shouldResetPanelWidth = false
                            }
                        }
                    }
                }
            }
        }
        .alert("Confirm Action", isPresented: $showActionConfirm) {
            Button("Cancel", role: .cancel) { pendingAction = nil }
            Button("Execute") { executePendingAction() }
        } message: {
            if let action = pendingAction {
                let typeText = action.type.rawValue
                let payloadKeys = action.payload?.keys.sorted() ?? []
                let payloadSummary = payloadKeys.isEmpty ? "none" : payloadKeys.joined(separator: ", ")
                Text("Assistant: \(pendingAssistantText)\n\nAction: \(typeText)\nPayload keys: \(payloadSummary)")
            } else {
                Text("No action to execute.")
            }
        }
        .sheet(isPresented: $showDownloadsHub) {
            DownloadsHubView()
        }
        .onAppear {
            web.tabManager = tabManager
            loadChatHistory()
            if tabManager.currentTab == nil {
                _ = tabManager.newTab(url: nil)
                if let id = tabManager.currentTab {
                    web.setActiveTab(id)
                    addressBarText = ""
                }
            }
            eventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown) { event in
                let key = event.charactersIgnoringModifiers ?? ""
                if event.modifierFlags.contains(.command) {
                    if key == "e" {
                        DispatchQueue.main.async { toggleAIPanel() }
                        return nil
                    }
                    if key == "t" {
                        DispatchQueue.main.async { newTab() }
                        return nil
                    }
                    if key == "w" {
                        DispatchQueue.main.async { closeCurrentTab() }
                        return nil
                    }
                    if key == "y" {
                        DispatchQueue.main.async { navigateToHistory() }
                        return nil
                    }
                    if key == "l" {
                        DispatchQueue.main.async { addressBarFocused = true }
                        return nil
                    }
                    // Cmd+R: reload current tab
                    if key == "r" {
                        DispatchQueue.main.async {
                            if let id = tabManager.currentTab { web.reload(in: id) }
                        }
                        return nil
                    }
                    // Cmd+P: print current page
                    if key == "p" {
                        DispatchQueue.main.async {
                            if let id = tabManager.currentTab { web.printPage(in: id) }
                        }
                        return nil
                    }
                    // Cmd+1...9: switch to tab by index
                    if key >= "1", key <= "9", let idx = Int(key), idx >= 1, idx <= 9 {
                        DispatchQueue.main.async {
                            if idx <= tabManager.tabCount() {
                                tabManager.switchToTab(index: idx - 1)
                            }
                        }
                        return nil
                    }
                    // Cmd+= / Cmd+Plus: zoom in
                    if key == "=" || key == "+" {
                        DispatchQueue.main.async { web.zoomIn(tabManager.currentTab) }
                        return nil
                    }
                    // Cmd+-: zoom out
                    if key == "-" {
                        DispatchQueue.main.async { web.zoomOut(tabManager.currentTab) }
                        return nil
                    }
                    // Cmd+0: zoom reset to 100%
                    if key == "0" {
                        DispatchQueue.main.async { web.zoomReset(tabManager.currentTab) }
                        return nil
                    }
                    // Cmd+F: find in page
                    if key == "f" {
                        DispatchQueue.main.async {
                            showBrowserFindBar.toggle()
                            if !showBrowserFindBar {
                                browserFindQuery = ""
                                if let id = tabManager.currentTab {
                                    web.clearFind(in: id)
                                }
                            }
                        }
                        return nil
                    }
                }
                // Address bar suggestions: Down/Up/Enter when dropdown is visible (keyboard selection + autofill)
                if addressBarKeyState.visible {
                    if event.keyCode == 125 { // Down
                        DispatchQueue.main.async {
                            addressBarKeyState.selectedIndex = min(addressBarKeyState.selectedIndex + 1, addressBarKeyState.totalCount - 1)
                        }
                        return nil
                    }
                    if event.keyCode == 126 { // Up
                        DispatchQueue.main.async {
                            addressBarKeyState.selectedIndex = max(0, addressBarKeyState.selectedIndex - 1)
                        }
                        return nil
                    }
                    if event.keyCode == 36 { // Return
                        DispatchQueue.main.async { addressBarKeyState.submitSelection = true }
                        return nil
                    }
                }
                if event.keyCode == 53 {
                    if showBrowserFindBar {
                        DispatchQueue.main.async {
                            showBrowserFindBar = false
                            browserFindQuery = ""
                            if let id = tabManager.currentTab { web.clearFind(in: id) }
                        }
                        return nil
                    }
                    DispatchQueue.main.async { restoreAddressBarOnEscape = true }
                    return nil
                }
                return event
            }
        }
        .onChange(of: tabManager.currentTab) { _, newId in
            if let id = newId {
                web.setActiveTab(id)
                syncAddressBarFromCurrentTab()
            } else {
                addressBarText = ""
            }
        }
        .onChange(of: web.currentURL) { _, _ in
            syncAddressBarFromCurrentTab()
            if web.currentURL != nil { isFirstLoad = false }
        }
        .onChange(of: restoreAddressBarOnEscape) { _, new in
            if new {
                syncAddressBarFromCurrentTab()
                addressBarFocused = false
                restoreAddressBarOnEscape = false
            }
        }
        .onChange(of: addressBarKeyState.selectedIndex) { _, newValue in
            guard addressBarKeyState.visible else { return }
            let h = historySuggestions.count
            let total = h + searchSuggestions.count
            guard newValue >= 0, newValue < total else { return }
            if newValue < h {
                addressBarText = historySuggestions[newValue].url.absoluteString
            } else {
                addressBarText = searchSuggestions[newValue - h]
            }
        }
        .onChange(of: addressBarKeyState.submitSelection) { _, new in
            if new {
                applySelectionAtIndex(addressBarKeyState.selectedIndex)
                addressBarKeyState.submitSelection = false
            }
        }
        .onChange(of: historySuggestions.count) { _, _ in
            if addressBarKeyState.visible {
                addressBarKeyState.totalCount = historySuggestions.count + searchSuggestions.count
                addressBarKeyState.selectedIndex = min(addressBarKeyState.selectedIndex, max(0, addressBarKeyState.totalCount - 1))
            }
        }
        .onChange(of: searchSuggestions.count) { _, _ in
            if addressBarKeyState.visible {
                addressBarKeyState.totalCount = historySuggestions.count + searchSuggestions.count
                addressBarKeyState.selectedIndex = min(addressBarKeyState.selectedIndex, max(0, addressBarKeyState.totalCount - 1))
            }
        }
        .onDisappear {
            saveChatHistory()
            if let m = eventMonitor {
                NSEvent.removeMonitor(m)
                eventMonitor = nil
            }
        }
    }

    // MARK: - Helpers

    private func syncAddressBarFromCurrentTab() {
        if let id = tabManager.currentTab {
            if let url = web.currentURL {
                tabManager.navigate(tab: id, to: url)
                let hide = url.absoluteString == "about:blank" || (url.scheme == "luma" && url.host == "ai")
                addressBarText = hide ? "" : url.absoluteString
            } else if let url = tabManager.tabURL[id] ?? nil {
                let hide = url.absoluteString == "about:blank" || (url.scheme == "luma" && url.host == "ai")
                addressBarText = hide ? "" : url.absoluteString
            } else {
                addressBarText = ""
            }
        } else {
            addressBarText = ""
        }
    }

    /// Selects the entire address bar contents when the user clicks/taps into it.
    /// Uses the current first responder (NSTextView) in the key window.
    private func selectAllAddressBarText() {
        DispatchQueue.main.async {
            if let editor = NSApp.keyWindow?.firstResponder as? NSTextView {
                editor.selectAll(nil)
            }
        }
    }

    private func fetchHistorySuggestions(for query: String) {
        historyDebounceTask?.cancel()
        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, trimmed.count >= 2 else {
            historySuggestions = []
            return
        }
        let task = DispatchWorkItem { [trimmed] in
            let results = HistoryManager.shared.urlAutocompleteSuggestions(prefix: trimmed, limit: 5)
            self.historySuggestions = results
        }
        historyDebounceTask = task
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05, execute: task)
    }

    private func fetchSearchSuggestions(for query: String) {
        suggestionDebounceTask?.cancel()
        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty, trimmed.count >= 2 else {
            searchSuggestions = []
            return
        }
        let task = DispatchWorkItem { [trimmed] in
            guard let encoded = trimmed.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
                  let url = URL(string: "https://suggestqueries.google.com/complete/search?client=firefox&q=\(encoded)") else { return }
            var request = URLRequest(url: url)
            request.timeoutInterval = 3
            URLSession.shared.dataTask(with: request) { data, _, _ in
                guard let data = data,
                      var raw = String(data: data, encoding: .utf8) else {
                    DispatchQueue.main.async { self.searchSuggestions = [] }
                    return
                }
                if raw.hasPrefix("window."), let start = raw.firstIndex(of: "["), let end = raw.lastIndex(of: "]") {
                    raw = String(raw[start...end])
                }
                guard let jsonData = raw.data(using: .utf8),
                      let json = try? JSONSerialization.jsonObject(with: jsonData) as? [Any],
                      json.count >= 2,
                      let rawSuggestions = json[1] as? [Any] else {
                    DispatchQueue.main.async { self.searchSuggestions = [] }
                    return
                }
                let phrases = rawSuggestions.compactMap { item -> String? in
                    if let s = item as? String { return s }
                    if let arr = item as? [Any], let first = arr.first as? String { return first }
                    return nil
                }
                DispatchQueue.main.async {
                    self.searchSuggestions = Array(phrases.prefix(5))
                }
            }.resume()
        }
        suggestionDebounceTask = task
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.18, execute: task)
    }

    private func resolveToURL(_ input: String) -> URL? {
        let trimmed = input.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }
        
        // Handle luma:// scheme
        if trimmed.lowercased().hasPrefix("luma://") {
            return URL(string: trimmed)
        }
        // Handle file:// so we don't turn it into https://file:///...
        if trimmed.lowercased().hasPrefix("file://") {
            return URL(string: trimmed)
        }
        if trimmed.lowercased().hasPrefix("http://") || trimmed.lowercased().hasPrefix("https://") {
            return URL(string: trimmed)
        }
        if !trimmed.contains(" "), trimmed.contains(".") {
            return URL(string: "https://" + trimmed)
        }
        let encoded = trimmed.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? trimmed
        return URL(string: "https://www.google.com/search?q=" + encoded)
    }

    /// Submit address bar: if first history suggestion matches typed prefix, go there; else resolve as URL or search.
    private func applyAddressBarSubmit() {
        let trimmed = addressBarText.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
        if !trimmed.isEmpty,
           let first = historySuggestions.first,
           first.display.lowercased().hasPrefix(trimmed)
            || first.url.absoluteString.lowercased().contains(trimmed)
            || (first.url.host?.lowercased().contains(trimmed) ?? false) {
            searchSuggestions = []
            historySuggestions = []
            addressBarKeyState.visible = false
            navigateToURL(first.url)
            return
        }
        searchSuggestions = []
        historySuggestions = []
        addressBarKeyState.visible = false
        navigateFromAddressBar()
    }

    /// Apply the currently selected suggestion (keyboard Enter): navigate to URL or run search.
    private func applySelectionAtIndex(_ index: Int) {
        let h = historySuggestions.count
        let total = h + searchSuggestions.count
        guard index >= 0, index < total else { return }
        if index < h {
            let url = historySuggestions[index].url
            searchSuggestions = []
            historySuggestions = []
            addressBarKeyState.visible = false
            navigateToURL(url)
        } else {
            let phrase = searchSuggestions[index - h]
            searchSuggestions = []
            historySuggestions = []
            addressBarKeyState.visible = false
            addressBarText = phrase
            navigateFromAddressBar()
        }
    }

    private func navigateFromAddressBar() {
        guard let url = resolveToURL(addressBarText) else { return }
        navigateToURL(url)
    }
    
    private func navigateToHistory() {
        // Always open History in a new tab
        if let url = URL(string: "luma://history") {
            let id = tabManager.newTab(url: url)
            web.setActiveTab(id)
            addressBarText = url.absoluteString
            isFirstLoad = false
            return
        }
    }

    private func navigateToURL(_ url: URL) {
        // Handle luma:// scheme
        if url.scheme == "luma" {
            if url.host == "history" {
                let id = tabManager.newTab(url: url)
                web.setActiveTab(id)
                addressBarText = url.absoluteString
                isFirstLoad = false
                return
            }
            if url.host == "ai" {
                return
            }
        }
        
        let title: String = (url.scheme == "file") ? url.lastPathComponent : (url.host ?? url.absoluteString)
        if tabManager.currentTab == nil {
            let id = tabManager.newTab(url: url)
            _ = web.ensureWebView(for: id)
            web.setActiveTab(id)
            web.load(url: url, in: id)
        } else if let id = tabManager.currentTab {
            tabManager.navigate(tab: id, to: url)
            web.load(url: url, in: id)
        }
        // Don't record start page (about:blank) in history
        if url.absoluteString != "about:blank" {
            tabManager.addNavigation(title: title, url: url)
            HistoryManager.shared.recordPageVisit(url: url, title: title)
        }
        addressBarText = url.absoluteString
    }

    private func newTabWithURL(_ url: URL) {
        let id = tabManager.newTab(url: url)
        _ = web.ensureWebView(for: id)
        web.setActiveTab(id)
        web.load(url: url, in: id)
        tabManager.navigate(tab: id, to: url)
        if url.absoluteString != "about:blank" {
            let title = url.host ?? url.absoluteString
            tabManager.addNavigation(title: title, url: url)
            HistoryManager.shared.recordPageVisit(url: url, title: title)
        }
        addressBarText = url.absoluteString
    }

    private func handleURLDrop(providers: [NSItemProvider], action: @escaping (URL) -> Void) -> Bool {
        guard let provider = providers.first else { return false }
        if provider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url, (u.scheme == "http" || u.scheme == "https" || u.scheme == "file") {
                    DispatchQueue.main.async { action(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.fileURL.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url {
                    DispatchQueue.main.async { action(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
            _ = provider.loadObject(ofClass: String.self) { str, _ in
                if let s = str?.trimmingCharacters(in: .whitespacesAndNewlines),
                   let u = URL(string: s),
                   u.scheme == "http" || u.scheme == "https" {
                    DispatchQueue.main.async { action(u) }
                }
            }
        }
        return true
    }

    private func aiChatMessagesBinding(for tabId: UUID) -> Binding<[ChatMessage]> {
        Binding(
            get: { tabAIChatMessages[tabId] ?? [] },
            set: { tabAIChatMessages[tabId] = $0 }
        )
    }

    private var isCurrentTabStartOrAIChat: Bool {
        guard let id = tabManager.currentTab,
              let url = tabManager.tabURL[id] ?? nil else { return true }
        if url.absoluteString == "about:blank" { return true }
        if url.scheme == "luma" && url.host == "ai" { return true }
        return false
    }

    private func toggleAIPanel() {
        guard let id = tabManager.currentTab else { return }
        guard !isCurrentTabStartOrAIChat else { return }
        if tabsWithPanelOpen.contains(id) {
            tabsWithPanelOpen.remove(id)
        } else {
            shouldResetPanelWidth = true
            tabsWithPanelOpen.insert(id)
        }
    }

    private func newTab() {
        let id = tabManager.newTab(url: nil)
        _ = web.ensureWebView(for: id)
        web.setActiveTab(id)
        web.load(url: URL(string: "about:blank")!, in: id)
        addressBarText = ""
        addressBarFocused = true
    }

    private func closeCurrentTab() {
        guard let id = tabManager.currentTab else { return }
        closeTab(id)
    }

    /// Heartbeat animation on downloads icon: pulse 25% bigger twice (1 → 1.25 → 1 → 1.25 → 1).
    private func runDownloadsHeartbeat() {
        let step: TimeInterval = 0.12
        withAnimation(.easeInOut(duration: step)) { downloadIconScale = 1.25 }
        DispatchQueue.main.asyncAfter(deadline: .now() + step) {
            withAnimation(.easeInOut(duration: step)) { downloadIconScale = 1 }
            DispatchQueue.main.asyncAfter(deadline: .now() + step) {
                withAnimation(.easeInOut(duration: step)) { downloadIconScale = 1.25 }
                DispatchQueue.main.asyncAfter(deadline: .now() + step) {
                    withAnimation(.easeInOut(duration: step)) { downloadIconScale = 1 }
                }
            }
        }
    }

    private func closeTab(_ id: UUID) {
        web.removeWebView(for: id)
        tabsWithPanelOpen.remove(id)
        tabChatHistory.removeValue(forKey: id)
        tabAIChatMessages.removeValue(forKey: id)
        tabManager.closeTab(id)
        if tabManager.currentTab == nil {
            newTab()
        } else if let newCurrent = tabManager.currentTab {
            web.setActiveTab(newCurrent)
            syncAddressBarFromCurrentTab()
        }
    }

    private func switchToTab(_ id: UUID) {
        tabManager.switchToTab(id)
        web.setActiveTab(id)
        syncAddressBarFromCurrentTab()
    }

    private func executePendingAction() {
        guard let action = pendingAction else { return }
        let tabToClose: UUID?
        if action.type == .close_tab, action.payload?["index"] == nil {
            tabToClose = tabManager.currentTab
        } else {
            tabToClose = nil
        }
        let result = router.execute(action: action, tabManager: tabManager)
        switch result {
        case .success:
            if let id = tabToClose {
                web.removeWebView(for: id)
            }
            if action.type == .new_tab || action.type == .navigate,
               let urlString = action.payload?["url"],
               let url = URL(string: urlString.contains("://") ? urlString : "https://" + urlString) {
                if action.type == .new_tab, let id = tabManager.currentTab {
                    web.setActiveTab(id)
                    web.load(url: url, in: id)
                    tabManager.navigate(tab: id, to: url)
                    addressBarText = url.absoluteString
                } else if action.type == .navigate, let id = tabManager.currentTab {
                    web.load(url: url, in: id)
                    tabManager.navigateCurrentTab(to: url)
                    addressBarText = url.absoluteString
                }
            }
        case .failure:
            break
        }
        pendingAction = nil
    }
    
    // MARK: - Chat History Persistence (in-app only; chat sessions are not recorded to History)
    
    private func saveChatHistory() {
        let encoder = JSONEncoder()
        var savedHistory: [String: Data] = [:]
        
        for (tabId, messages) in tabChatHistory {
            if let encoded = try? encoder.encode(messages) {
                savedHistory[tabId.uuidString] = encoded
            }
        }
        
        // Save to UserDefaults with a size limit
        let defaults = UserDefaults.standard
        for (key, value) in savedHistory {
            defaults.set(value, forKey: "chat_history_\(key)")
        }
    }
    
    private func loadChatHistory() {
        let decoder = JSONDecoder()
        let defaults = UserDefaults.standard
        
        // Get all keys that match our chat history pattern
        let allKeys = defaults.dictionaryRepresentation().keys
        let chatKeys = allKeys.filter { $0.hasPrefix("chat_history_") }
        
        for key in chatKeys {
            let uuidString = key.replacingOccurrences(of: "chat_history_", with: "")
            guard let uuid = UUID(uuidString: uuidString),
                  let data = defaults.data(forKey: key),
                  let messages = try? decoder.decode([ChatMessage].self, from: data) else {
                continue
            }
            tabChatHistory[uuid] = messages
        }
    }
}

// MARK: - Downloads hub (recent downloads; open / reveal in Finder)

private struct DownloadsHubView: View {
    @ObservedObject private var downloadManager = DownloadManager.shared
    @Environment(\.dismiss) private var dismiss

    private static let dateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.dateStyle = .short
        f.timeStyle = .short
        return f
    }()

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Image(systemName: "arrow.down.circle")
                    .font(.system(size: 18, weight: .medium))
                Text("Downloads")
                    .font(.system(size: 18, weight: .semibold))
                Spacer()
                Button("Done") { dismiss() }
                    .buttonStyle(.borderedProminent)
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 14)
            .background(Color(white: 0.12))

            if downloadManager.recentDownloads.isEmpty {
                VStack(spacing: 12) {
                    Image(systemName: "tray.and.arrow.down")
                        .font(.system(size: 40))
                        .foregroundStyle(.secondary)
                    Text("No recent downloads")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                List {
                    ForEach(downloadManager.recentDownloads) { item in
                        HStack(spacing: 12) {
                            Image(systemName: "doc.fill")
                                .font(.system(size: 20))
                                .foregroundStyle(.secondary)
                            VStack(alignment: .leading, spacing: 2) {
                                Text(item.suggestedFilename)
                                    .font(.system(size: 13, weight: .medium))
                                    .lineLimit(1)
                                    .truncationMode(.middle)
                                Text(Self.dateFormatter.string(from: item.date))
                                    .font(.system(size: 11))
                                    .foregroundStyle(.secondary)
                            }
                            .frame(maxWidth: .infinity, alignment: .leading)
                            Button("Open") {
                                downloadManager.open(item)
                            }
                            .buttonStyle(.bordered)
                            Button("Show in Finder") {
                                downloadManager.revealInFinder(item)
                            }
                            .buttonStyle(.bordered)
                            Button(role: .destructive) {
                                downloadManager.removeItem(item)
                            } label: {
                                Image(systemName: "trash")
                                    .font(.system(size: 12, weight: .medium))
                            }
                            .buttonStyle(.plain)
                            .help("Remove from list")
                        }
                        .padding(.vertical, 4)
                    }
                }
                .listStyle(.plain)
            }
        }
        .frame(minWidth: 420, minHeight: 320)
        .background(Color(white: 0.11))
    }
}

// MARK: - Google “suspicious request” banner + help (DIA-style: explain it’s Google’s decision, not Luma)

private struct GoogleSuspiciousErrorBanner: View {
    let onDismiss: () -> Void
    let onLearnMore: () -> Void

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: "exclamationmark.triangle.fill")
                .font(.system(size: 16))
                .foregroundColor(.orange)
            VStack(alignment: .leading, spacing: 4) {
                Text("Google is blocking API key creation for this request.")
                    .font(.system(size: 13, weight: .medium))
                    .foregroundColor(.primary)
                Text("This is a Google security decision, not a problem with Luma.")
                    .font(.system(size: 12))
                    .foregroundColor(.secondary)
            }
            .frame(maxWidth: .infinity, alignment: .leading)
            Button("Learn more") { onLearnMore() }
                .buttonStyle(.borderedProminent)
            Button("Dismiss") { onDismiss() }
                .buttonStyle(.bordered)
        }
        .padding(14)
        .background(Color(nsColor: .windowBackgroundColor).opacity(0.95))
        .clipShape(RoundedRectangle(cornerRadius: 10))
        .shadow(color: .black.opacity(0.15), radius: 8)
    }
}

private struct GoogleAPIKeyHelpView: View {
    @Environment(\.dismiss) private var dismiss
    private let googleSecurityURL = URL(string: "https://myaccount.google.com/security")!
    private let aiStudioURL = URL(string: "https://aistudio.google.com/app/apikey")!

    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            HStack {
                Text("Trouble creating Google AI keys?")
                    .font(.system(size: 18, weight: .semibold))
                Spacer()
                Button("Done") { dismiss() }
                    .buttonStyle(.borderedProminent)
            }
            .padding(.bottom, 4)
            Text("When you see “The request is suspicious” on Google AI Studio, Google’s systems are blocking that action — for example because of account type, region, network, or past security events. Luma cannot override this.")
                .font(.system(size: 13))
                .foregroundColor(.secondary)
                .fixedSize(horizontal: false, vertical: true)
            VStack(alignment: .leading, spacing: 8) {
                Text("What you can do:")
                    .font(.system(size: 13, weight: .semibold))
                Text("• Check your Google Account security and sign-in history.")
                Text("• Try again later or from a different network.")
                Text("• Create the API key in Chrome or Safari, then paste it into Luma Settings.")
            }
            .font(.system(size: 13))
            .foregroundColor(.primary)
            Spacer()
            HStack(spacing: 12) {
                Link("Google Account security", destination: googleSecurityURL)
                Link("Google AI Studio", destination: aiStudioURL)
            }
            .font(.system(size: 12))
        }
        .padding(24)
        .frame(minWidth: 420, minHeight: 320)
    }
}

// MARK: - Address bar suggestions (history first, then search)

private struct AddressBarSuggestionsList: View {
    let historyItems: [(display: String, url: URL)]
    let searchPhrases: [String]
    var selectedIndex: Int = 0
    let onSelectHistory: (URL) -> Void
    let onSelectSearch: (String) -> Void
    @State private var hoveredSection: String? = nil  // "h-0", "s-0", etc.

    private func isSelected(historyIndex: Int) -> Bool { selectedIndex == historyIndex }
    private func isSelected(searchIndex: Int) -> Bool { selectedIndex == historyItems.count + searchIndex }

    var body: some View {
        VStack(spacing: 0) {
            ForEach(Array(historyItems.enumerated()), id: \.offset) { index, item in
                let id = "h-\(index)"
                let selected = isSelected(historyIndex: index)
                Button(action: { onSelectHistory(item.url) }) {
                    HStack {
                        Image(systemName: "clock.arrow.circlepath")
                            .font(.system(size: 11))
                            .foregroundStyle(.secondary)
                            .frame(width: 20)
                        VStack(alignment: .leading, spacing: 2) {
                            Text(item.display)
                                .font(.system(size: 13))
                                .foregroundStyle(.primary)
                                .lineLimit(1)
                            if let host = item.url.host, host != item.display {
                                Text(host)
                                    .font(.system(size: 11))
                                    .foregroundStyle(.secondary)
                                    .lineLimit(1)
                            }
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .contentShape(Rectangle())
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(selected || hoveredSection == id ? Color.primary.opacity(0.06) : Color.clear)
                    )
                    .onHover { hovering in hoveredSection = hovering ? id : nil }
                }
                .buttonStyle(.plain)
            }
            ForEach(Array(searchPhrases.enumerated()), id: \.offset) { index, phrase in
                let id = "s-\(index)"
                let selected = isSelected(searchIndex: index)
                Button(action: { onSelectSearch(phrase) }) {
                    HStack {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 11))
                            .foregroundStyle(.secondary)
                            .frame(width: 20)
                        Text(phrase)
                            .font(.system(size: 13))
                            .foregroundStyle(.primary)
                            .lineLimit(1)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .contentShape(Rectangle())
                    .background(
                        RoundedRectangle(cornerRadius: 4)
                            .fill(selected || hoveredSection == id ? Color.primary.opacity(0.06) : Color.clear)
                    )
                    .onHover { hovering in hoveredSection = hovering ? id : nil }
                }
                .buttonStyle(.plain)
            }
        }
    }
}

// MARK: - History sheet

private struct HistoryView: View {
    let entries: [HistoryEntry]
    let onSelect: (URL) -> Void
    let onDismiss: () -> Void

    private static let dateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.dateStyle = .short
        f.timeStyle = .short
        return f
    }()

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Text("History").font(.headline)
                Spacer()
                Button("Done", action: onDismiss)
                    .keyboardShortcut(.escape, modifiers: [])
            }
            .padding()
            Divider()
            if entries.isEmpty {
                Text("No history yet")
                    .foregroundColor(.secondary)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                List(entries) { entry in
                    Button {
                        onSelect(entry.url)
                    } label: {
                        VStack(alignment: .leading, spacing: 2) {
                            Text(entry.title).lineLimit(1).font(.system(size: 13, weight: .medium))
                            Text(entry.url.absoluteString).lineLimit(1).font(.caption).foregroundColor(.secondary)
                            Text(Self.dateFormatter.string(from: entry.date)).font(.caption2).foregroundColor(.secondary.opacity(0.8))
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.vertical, 4)
                    }
                    .buttonStyle(.plain)
                }
                .listStyle(.plain)
            }
        }
        .frame(minWidth: 400, minHeight: 300)
    }
}

// MARK: - Panel resize handle

private struct PanelResizeHandle: View {
    @Binding var panelWidth: CGFloat
    let windowWidth: CGFloat
    @Binding var isDragging: Bool

    @State private var dragStartWidth: CGFloat? = nil
    @State private var isHovering: Bool = false

    private var minWidth: CGFloat { windowWidth / 10 }
    private var maxWidth: CGFloat { windowWidth / 2 }

    var body: some View {
        Rectangle()
            .fill(
                (isHovering || isDragging)
                    ? Color.white.opacity(0.3)
                    : Color.white.opacity(0.1)
            )
            .frame(width: 6)
            .contentShape(Rectangle())
            .onHover { hovering in
                isHovering = hovering
                if !isDragging {
                    if hovering { NSCursor.resizeLeftRight.push() }
                    else { NSCursor.pop() }
                }
            }
            .gesture(
                DragGesture(minimumDistance: 0) // local space is fine
                    .onChanged { value in
                        // Remember the width at drag start
                        if dragStartWidth == nil {
                            dragStartWidth = panelWidth
                            isDragging = true
                            NSCursor.resizeLeftRight.push()
                        }

                        // Panel on the RIGHT: drag right -> smaller, drag left -> bigger (opposite of cursor direction)
                        let base = dragStartWidth ?? panelWidth
                        let proposed = base - value.translation.width
                        let clamped = min(maxWidth, max(minWidth, proposed))

                        panelWidth = clamped
                    }
                    .onEnded { _ in
                        dragStartWidth = nil
                        isDragging = false
                        NSCursor.pop()
                    }
            )
    }
}
// MARK: - Tab strip (Chrome-style dynamic width: min/max, clamp, overflow)
// Parent applies .padding(.leading, 78) to clear traffic lights.

private struct TabStripView: View {
    @ObservedObject var tabManager: TabManager
    let faviconURLByTab: [UUID: URL?]
    let contentAreaColor: Color
    let chromeTextIsLight: Bool
    let onSwitch: (UUID) -> Void
    let onClose: (UUID) -> Void
    let onNewTab: () -> Void
    let onDropURLForNewTab: (URL) -> Void
    let onReorder: (Int, Int) -> Void

    @State private var draggedTab: UUID? = nil
    private let rowHeight: CGFloat = 30

    /// Chrome-style tab geometry: ideal = W/N, tabWidth = clamp(ideal, min, max); overflow → shrink to emergency min.
    private static let minTabWidth: CGFloat = 80
    private static let maxTabWidth: CGFloat = 240
    private static let emergencyMinTabWidth: CGFloat = 44
    private static let newTabButtonWidth: CGFloat = 32
    private static let newTabGap: CGFloat = 4

    var body: some View {
        GeometryReader { geometry in
            let N = tabManager.tabCount()
            let W = max(0, geometry.size.width - Self.newTabButtonWidth - Self.newTabGap)
            let ideal = N > 0 ? W / CGFloat(N) : 0
            // Chrome-style: roomy → clamp(ideal, min, max); cramped → shrink to emergency min so strip doesn’t overflow
            let tabWidth: CGFloat = N > 0
                ? min(Self.maxTabWidth, ideal >= Self.minTabWidth ? ideal : max(Self.emergencyMinTabWidth, ideal))
                : 0

            HStack(spacing: 0) {
                ForEach(Array(tabManager.tabOrder.enumerated()), id: \.element) { index, tabId in
                    TabPill(
                        tabId: tabId,
                        index: index + 1,
                        url: tabManager.tabURL[tabId] ?? nil,
                        title: tabManager.tabTitle[tabId],
                        faviconURL: faviconURLByTab[tabId] ?? nil,
                        isActive: tabManager.currentTab == tabId,
                        contentAreaColor: contentAreaColor,
                        chromeTextIsLight: chromeTextIsLight,
                        showTitle: tabWidth >= Self.minTabWidth,
                        onSelect: { onSwitch(tabId) },
                        onClose: { onClose(tabId) }
                    )
                    .background(NonDraggableWindowView())
                    .frame(width: tabWidth, height: rowHeight)
                    .id(tabId)
                    .opacity(draggedTab == tabId ? 0.5 : 1.0)
                    .onDrag {
                        draggedTab = tabId
                        return NSItemProvider(object: tabId.uuidString as NSString)
                    }
                    .onDrop(of: [.plainText], delegate: TabDropDelegate(
                        destinationTab: tabId,
                        tabs: tabManager.tabOrder,
                        draggedTab: $draggedTab,
                        onReorder: onReorder
                    ))
                }

                Button(action: onNewTab) {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.white.opacity(0.7))
                        .frame(width: 32, height: rowHeight - 4)
                        .contentShape(Rectangle())
                        .background(RoundedRectangle(cornerRadius: 6).fill(Color(white: 0.22).opacity(0.6)))
                }
                .background(NonDraggableWindowView())
                .buttonStyle(.plain)
                .accessibilityLabel("New tab")
                .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
                    urlDropHandler(providers: providers)
                }

                // Only the empty toolbar space moves the window; tabs stay stationary for reordering
                WindowDragRegionView()
                    .frame(maxWidth: .infinity)
                    .allowsHitTesting(true)
            }
            .frame(maxWidth: .infinity)
            .animation(.easeInOut(duration: 0.06), value: tabManager.tabCount())
            .animation(.easeInOut(duration: 0.06), value: geometry.size.width)
        }
        .frame(maxWidth: .infinity)
        .onDrop(of: [.url, .fileURL, .plainText], isTargeted: nil) { providers in
            urlDropHandler(providers: providers)
        }
    }

    private func urlDropHandler(providers: [NSItemProvider]) -> Bool {
        guard let provider = providers.first else { return false }
        if provider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url, (u.scheme == "http" || u.scheme == "https" || u.scheme == "file") {
                    DispatchQueue.main.async { onDropURLForNewTab(u) }
                }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.fileURL.identifier) {
            _ = provider.loadObject(ofClass: URL.self) { url, _ in
                if let u = url { DispatchQueue.main.async { onDropURLForNewTab(u) } }
            }
        } else if provider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
            _ = provider.loadObject(ofClass: String.self) { str, _ in
                if let s = str?.trimmingCharacters(in: .whitespacesAndNewlines),
                   let u = URL(string: s),
                   u.scheme == "http" || u.scheme == "https" {
                    DispatchQueue.main.async { onDropURLForNewTab(u) }
                }
            }
        }
        return true
    }
}

private struct TabPill: View {
    let tabId: UUID
    let index: Int
    let url: URL?
    let title: String?
    let faviconURL: URL?
    let isActive: Bool
    let contentAreaColor: Color
    let chromeTextIsLight: Bool
    /// When false (cramped strip), show only favicon to fit; when true, show title too.
    let showTitle: Bool
    let onSelect: () -> Void
    let onClose: () -> Void
    @State private var isHovered = false

    private var displayTitle: String {
        // Use provided title from page if available
        if let title = title, !title.isEmpty { return title }
        
        // Fallback to URL-based titles
        if url == nil || url?.absoluteString == "about:blank" { return "New Tab" }
        if url?.scheme == "luma", url?.host == "history" { return "History" }
        if url?.scheme == "luma", url?.host == "ai" { return "AI Chat" }
        if url?.scheme == "file" { return url?.lastPathComponent ?? "File" }
        return url?.host ?? url?.absoluteString ?? "New Tab"
    }
    private var tabTextColor: Color {
        if url?.scheme == "luma" {
            return isActive ? .white : .white.opacity(0.7)
        }
        if isActive { return chromeTextIsLight ? .white : Color(white: 0.15) }
        return .white.opacity(0.7)
    }

    var body: some View {
        HStack(spacing: 0) {
            Button(action: onSelect) {
                HStack(spacing: showTitle ? 6 : 0) {
                    Group {
                        if let url = url, url.scheme == "luma", url.host == "ai" {
                            Image(systemName: "bubble.left.and.bubble.right.fill")
                                .font(.system(size: 10, weight: .medium))
                                .foregroundColor(tabTextColor)
                        } else if let url = url {
                            FaviconView(url: url, faviconURL: faviconURL)
                                .frame(width: 14, height: 14)
                        } else {
                            Image(systemName: "globe")
                                .font(.system(size: 11, weight: .medium))
                                .foregroundColor(tabTextColor)
                        }
                    }
                    .frame(width: 14, height: 14, alignment: .center)
                    if showTitle {
                        Text(displayTitle)
                            .lineLimit(1)
                            .truncationMode(.tail)
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(tabTextColor)
                            .frame(maxWidth: .infinity, alignment: .leading)
                    }
                }
                .padding(.leading, 8)
                .padding(.trailing, showTitle ? 4 : 6)
                .padding(.vertical, 4)
                .contentShape(Rectangle())
                .frame(maxWidth: .infinity)
            }
            .buttonStyle(.plain)

            Button(action: onClose) {
                Image(systemName: "xmark")
                    .font(.system(size: 9, weight: .semibold))
                    .foregroundColor(tabTextColor.opacity(0.8))
                    .frame(width: 20, height: 20)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            .opacity(isHovered || isActive ? 1 : 0)
            .allowsHitTesting(isHovered || isActive)
        }
        .onHover { isHovered = $0 }
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(isActive
                    ? contentAreaColor
                    : Color(white: 0.22).opacity(isHovered ? 0.9 : 0.6))
        )
        .animation(.easeInOut(duration: 0.06), value: contentAreaColor)
        .animation(.easeInOut(duration: 0.06), value: isHovered)
        .animation(.easeInOut(duration: 0.06), value: isActive)
        .accessibilityElement(children: .combine)
        .accessibilityLabel("Tab \(index): \(displayTitle)")
        .accessibilityAddTraits(isActive ? [.isButton, .isSelected] : .isButton)
    }
}

// MARK: - NSViewRepresentables

struct WebViewContainer: NSViewRepresentable {
    let webView: WKWebView
    func makeNSView(context: Context) -> WKWebView { webView }
    func updateNSView(_ nsView: WKWebView, context: Context) {}
}

/// NSView that disallows window drag (returns false for mouseDownCanMoveWindow).
/// Used behind tabs so dragging a tab doesn't move the window.
private final class NonDraggableWindowNSView: NSView {
    override var mouseDownCanMoveWindow: Bool { false }
}

struct NonDraggableWindowView: NSViewRepresentable {
    func makeNSView(context: Context) -> NSView { NonDraggableWindowNSView() }
    func updateNSView(_ nsView: NSView, context: Context) {}
}

// MARK: - Tab Drop Delegate (smooth live reordering during drag)

private struct TabDropDelegate: DropDelegate {
    let destinationTab: UUID
    let tabs: [UUID]
    @Binding var draggedTab: UUID?
    let onReorder: (Int, Int) -> Void
    
    func dropEntered(info: DropInfo) {
        guard let draggedTab = draggedTab else { return }
        guard let fromIndex = tabs.firstIndex(of: draggedTab),
              let toIndex = tabs.firstIndex(of: destinationTab),
              fromIndex != toIndex else { return }
        
        withAnimation(.easeInOut(duration: 0.25)) {
            onReorder(fromIndex, toIndex)
        }
    }
    
    func performDrop(info: DropInfo) -> Bool {
        draggedTab = nil
        return true
    }
    
    func dropUpdated(info: DropInfo) -> DropProposal? {
        DropProposal(operation: .move)
    }
}

/// NSView that allows window drag only when hit (used for empty toolbar space).
// MARK: - Browser Find Bar (Cmd+F)

private struct BrowserFindBar: View {
    @Binding var query: String
    let onFind: (String) -> Void
    let onNext: () -> Void
    let onPrevious: () -> Void
    let onDismiss: () -> Void
    @FocusState private var isFocused: Bool

    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: 12, weight: .medium))
                .foregroundColor(Color.white.opacity(0.5))
            TextField("Find in page\u{2026}", text: $query)
                .textFieldStyle(.plain)
                .font(.system(size: 13))
                .foregroundColor(Color.white.opacity(0.9))
                .focused($isFocused)
                .onSubmit { onFind(query) }
                .onChange(of: query) { _, newValue in
                    if !newValue.isEmpty { onFind(newValue) }
                }
            Button(action: onPrevious) {
                Image(systemName: "chevron.up")
                    .font(.system(size: 11, weight: .semibold))
                    .foregroundColor(Color.white.opacity(0.6))
                    .frame(width: 22, height: 22)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            Button(action: onNext) {
                Image(systemName: "chevron.down")
                    .font(.system(size: 11, weight: .semibold))
                    .foregroundColor(Color.white.opacity(0.6))
                    .frame(width: 22, height: 22)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
            Button(action: onDismiss) {
                Image(systemName: "xmark")
                    .font(.system(size: 11, weight: .medium))
                    .foregroundColor(Color.white.opacity(0.6))
                    .frame(width: 22, height: 22)
                    .contentShape(Rectangle())
            }
            .buttonStyle(.plain)
        }
        .padding(.horizontal, 14)
        .padding(.vertical, 8)
        .background(
            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .fill(Color(white: 0.15))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 10, style: .continuous)
                .stroke(Color.white.opacity(0.12), lineWidth: 1)
        )
        .frame(maxWidth: 340)
        .padding(.trailing, 16)
        .padding(.top, 8)
        .frame(maxWidth: .infinity, alignment: .trailing)
        .onAppear { isFocused = true }
    }
}

private final class WindowDragRegionNSView: NSView {
    override var mouseDownCanMoveWindow: Bool { true }
}

/// Place this only in the empty toolbar space (e.g. after tabs and + button).
/// Dragging from here moves the window; dragging from tabs reorders tabs.
struct WindowDragRegionView: NSViewRepresentable {
    func makeNSView(context: Context) -> NSView { WindowDragRegionNSView() }
    func updateNSView(_ nsView: NSView, context: Context) {}
}

/// Configures the window for a Chrome/Dia-style titlebar:
/// - titlebar is transparent so we can paint over it
/// - title text is hidden
/// - titlebar height is enlarged to fit the tab strip
///
/// The `tabStripHeight` parameter tells us how tall our tab strip is so we
/// can match the titlebar to it exactly.
struct TitlebarConfigurator: NSViewRepresentable {
    let tabStripHeight: CGFloat

    func makeNSView(context: Context) -> NSView {
        let view = NSView()
        DispatchQueue.main.async {
            guard let window = view.window else { return }
            window.titlebarAppearsTransparent = true
            window.titleVisibility = .hidden
            window.styleMask.insert(.fullSizeContentView)
            window.isMovableByWindowBackground = false
        }
        return view
    }

    func updateNSView(_ nsView: NSView, context: Context) {}
}

#Preview {
    BrowserShellView()
}

// MARK: - SplitBrowserShell integration

// import AppKit

// struct SplitBrowserShell: NSViewControllerRepresentable {
//     let webView: WKWebView
//     let aiPanel: AnyView

//     func makeNSViewController(context: Context) -> SplitBrowserShellController {
//         SplitBrowserShellController(webView: webView, aiPanel: aiPanel)
//     }
//     func updateNSViewController(_ nsViewController: SplitBrowserShellController, context: Context) {}
// }

// Usage:
// Replace your HStack browser/AI panel region with:
// SplitBrowserShell(webView: web.ensureWebView(for: currentId), aiPanel: AnyView(CommandSurfaceView(...)))
// To toggle panel: call splitVC.toggleAIPanel(true/false)
// You may need to refactor state management to coordinate panel open/close and width.
