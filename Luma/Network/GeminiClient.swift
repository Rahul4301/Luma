// Luma MVP - autogenerated by Cursor
import Foundation

/// User-facing network error for UI display. Never contains keys or stack traces.
enum GeminiError: LocalizedError {
    case noAPIKeyOrUnauthorized
    case endpointNotFound
    case networkFailure(String)

    var errorDescription: String? {
        switch self {
        case .noAPIKeyOrUnauthorized:
            return "Unauthorized (401). Your API key is missing/invalid."
        case .endpointNotFound:
            return "Gemini API returned 404 (endpoint not found). Check provider endpoint or API version."
        case .networkFailure(let msg):
            return "Network error: \(msg)"
        }
    }
}

/// Client for Gemini API calls (BYO key only in MVP).
///
/// Per SECURITY.md: Keys stored in Keychain, never in code or logs.
/// Per AGENTS.md: All network calls must be explicit and attributable to user request.
final class GeminiClient {

    /// Last network error message (user-facing only). Cleared on success. Memory only; never logged.
    static var lastNetworkError: String?

    /// Clears client caches (e.g. lastNetworkError). Call after key save/delete in Settings.
    static func clearClientCaches() {
        lastNetworkError = nil
    }

    private let apiKeyProvider: () -> String?
    
    /// Initializes client with a closure that provides the API key.
    /// Key should be retrieved from Keychain (via KeychainManager) when needed.
    /// Per SECURITY.md: Never store keys in code, UserDefaults, or logs.
    init(apiKeyProvider: @escaping () -> String?) {
        self.apiKeyProvider = apiKeyProvider
    }
    
    /// Generates a response from Gemini API via HTTPS POST.
    /// 
    /// - Parameters:
    ///   - prompt: User's prompt/query
    ///   - context: Optional context (selected text or excerpt) - only when user requests
    ///   - recentMessages: Last few messages for immediate context (not full history to save tokens)
    ///   - conversationSummary: Optional summary of older messages for extended context
    ///   - completion: Callback with Result containing LLMResponse JSON Data or Error
    func generate(prompt: String, context: String?, recentMessages: [ChatMessage] = [], conversationSummary: String? = nil, completion: @escaping (Result<Data, Error>) -> Void) {
        // Fail closed if no API key
        guard let apiKey = apiKeyProvider() else {
            Self.lastNetworkError = "No API key available. Add key in Settings."
            DispatchQueue.main.async {
                completion(.failure(GeminiError.noAPIKeyOrUnauthorized))
            }
            return
        }

        // Build the request URL
        guard let url = URL(string: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=\(apiKey)") else {
            Self.lastNetworkError = "Invalid Gemini API URL"
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidURL))
            }
            return
        }
        
        // Build request body: include only last few messages to save tokens
        var contents: [[String: Any]] = []
        
        // Only include recent context (last 2-3 exchanges) to save tokens
        // This provides immediate context without sending entire conversation
        for message in recentMessages {
            let role = message.role == .user ? "user" : "model"
            contents.append([
                "role": role,
                "parts": [["text": message.text]]
            ])
        }
        
        // Add current user message with context
        let userMessage: String
        if let context = context, !context.isEmpty {
            userMessage = """
            The user asks: \(prompt)

            Use the following context (current page and/or uploaded documents) to answer. Do not simply echo it back—summarize, explain, cross-reference, or respond to the question:

            \(context)
            """
        } else {
            userMessage = prompt
        }

        contents.append([
            "role": "user",
            "parts": [["text": userMessage]]
        ])

        let systemInstruction = """
        You are Luma, a helpful browser assistant with full awareness of the page context and any uploaded documents.
        You automatically receive the current page's title, URL, and content with every request, and may also receive document contents (PDF, text, etc.) the user has attached.
        Use this context proactively to provide relevant, contextual answers. When multiple documents or the page are provided, you may summarize, compare, or synthesize across them.
        
        You have access to the last few messages for immediate conversational context.
        \(conversationSummary != nil ? "\nPrevious conversation summary: \(conversationSummary!)" : "")
        
        Respond naturally with full, free-form text using markdown when it helps clarity.
        Provide complete, detailed answers—no arbitrary length limits.
        
        DO NOT copy or echo page content verbatim. Summarize, explain, or respond meaningfully.
        """

        var requestBody: [String: Any] = [
            "contents": contents
        ]
        requestBody["systemInstruction"] = [
            "parts": [["text": systemInstruction]]
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            Self.lastNetworkError = "Failed to build request"
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidRequest))
            }
            return
        }
        
        // Create URLRequest
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        // Make the network call
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    Self.lastNetworkError = "Network error: \(error.localizedDescription)"
                    completion(.failure(GeminiError.networkFailure(error.localizedDescription)))
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse else {
                    Self.lastNetworkError = "Invalid response from server"
                    completion(.failure(GeminiAPIError.invalidResponse))
                    return
                }

                guard (200...299).contains(httpResponse.statusCode) else {
                    let userMsg = Self.userMessageForHTTPStatus(httpResponse.statusCode, body: data)
                    Self.lastNetworkError = userMsg
                    switch httpResponse.statusCode {
                    case 401:
                        completion(.failure(GeminiError.noAPIKeyOrUnauthorized))
                    case 404:
                        completion(.failure(GeminiError.endpointNotFound))
                    default:
                        completion(.failure(GeminiAPIError.httpError(statusCode: httpResponse.statusCode)))
                    }
                    return
                }

                guard let data = data else {
                    Self.lastNetworkError = "No data received from server"
                    completion(.failure(GeminiAPIError.noData))
                    return
                }
                
                // Parse Gemini's response format
                do {
                    guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                          let candidates = json["candidates"] as? [[String: Any]],
                          let firstCandidate = candidates.first,
                          let content = firstCandidate["content"] as? [String: Any],
                          let parts = content["parts"] as? [[String: Any]] else {
                        Self.lastNetworkError = "Response format not recognized"
                        completion(.failure(GeminiAPIError.invalidResponseFormat))
                        return
                    }
                    let text = parts.compactMap { $0["text"] as? String }.joined()
                    guard !text.isEmpty else {
                        Self.lastNetworkError = "Response format not recognized"
                        completion(.failure(GeminiAPIError.invalidResponseFormat))
                        return
                    }
                    
                    // Transform Gemini response into our LLMResponse format
                    // For now, we'll try to parse action from the text if it contains JSON
                    var browserAction: BrowserAction? = nil
                    
                    // Try to extract JSON action from text (simple heuristic)
                    if let jsonRange = text.range(of: "```json", options: .caseInsensitive) ?? text.range(of: "{", options: []),
                       let jsonEndRange = text.range(of: "}", options: [], range: jsonRange.upperBound..<text.endIndex) {
                        let jsonString = String(text[jsonRange.lowerBound..<jsonEndRange.upperBound])
                            .replacingOccurrences(of: "```json", with: "")
                            .replacingOccurrences(of: "```", with: "")
                            .trimmingCharacters(in: .whitespacesAndNewlines)
                        
                        if let jsonData = jsonString.data(using: .utf8),
                           let parsed = try? JSONDecoder().decode(LLMResponse.self, from: jsonData) {
                            browserAction = parsed.action
                        }
                    }
                    
                    // Create our LLMResponse
                    let lumaResponse = LLMResponse(
                        text: text,
                        action: browserAction
                    )
                    
                    // Encode back to Data
                    let encoder = JSONEncoder()
                    let responseData = try encoder.encode(lumaResponse)
                    Self.lastNetworkError = nil
                    completion(.success(responseData))

                } catch {
                    Self.lastNetworkError = error.localizedDescription
                    completion(.failure(error))
                }
            }
        }.resume()
    }
    
    /// Generates a concise summary of conversation messages.
    /// Used to compress older messages into a summary for token efficiency.
    ///
    /// - Parameters:
    ///   - messages: Messages to summarize
    ///   - completion: Callback with Result containing summary string or Error
    func summarizeConversation(messages: [ChatMessage], completion: @escaping (Result<String, Error>) -> Void) {
        guard let apiKey = apiKeyProvider() else {
            Self.lastNetworkError = "No API key available. Add key in Settings."
            DispatchQueue.main.async {
                completion(.failure(GeminiError.noAPIKeyOrUnauthorized))
            }
            return
        }
        
        guard let url = URL(string: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=\(apiKey)") else {
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidURL))
            }
            return
        }
        
        // Build conversation text
        let conversationText = messages.map { msg in
            let role = msg.role == .user ? "User" : "Assistant"
            return "\(role): \(msg.text)"
        }.joined(separator: "\n\n")
        
        let summaryPrompt = """
        Create a concise summary (2-3 sentences) of the key points, questions asked, and information discussed in this conversation. Focus on facts and context that would be useful to reference later.
        
        Conversation:
        \(conversationText)
        """
        
        let contents: [[String: Any]] = [
            [
                "role": "user",
                "parts": [["text": summaryPrompt]]
            ]
        ]
        
        let requestBody: [String: Any] = ["contents": contents]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidRequest))
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(error))
                    return
                }
                
                guard let data = data,
                      let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
                      let candidates = json["candidates"] as? [[String: Any]],
                      let firstCandidate = candidates.first,
                      let content = firstCandidate["content"] as? [String: Any],
                      let parts = content["parts"] as? [[String: Any]] else {
                    completion(.failure(GeminiAPIError.invalidResponseFormat))
                    return
                }
                
                let summary = parts.compactMap { $0["text"] as? String }.joined()
                completion(.success(summary))
            }
        }.resume()
    }

    private static func userMessageForHTTPStatus(_ code: Int, body: Data?) -> String {
        switch code {
        case 401:
            return "Unauthorized (401). Your API key is missing/invalid."
        case 404:
            return "Gemini API returned 404 (endpoint not found). Check provider endpoint or API version."
        default:
            var msg = "Gemini API returned \(code)."
            if let body = body, let json = try? JSONSerialization.jsonObject(with: body) as? [String: Any],
               let err = json["error"] as? [String: Any], let m = err["message"] as? String, !m.isEmpty {
                msg += " \(m)"
            }
            return msg
        }
    }
}

/// Errors that can occur during Gemini API calls.
enum GeminiAPIError: LocalizedError {
    case invalidURL
    case invalidRequest
    case invalidResponse
    case invalidResponseFormat
    case noData
    case httpError(statusCode: Int)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid Gemini API URL"
        case .invalidRequest:
            return "Failed to build request"
        case .invalidResponse:
            return "Invalid response from server"
        case .invalidResponseFormat:
            return "Response format not recognized"
        case .noData:
            return "No data received from server"
        case .httpError(let code):
            return "HTTP error: \(code)"
        }
    }
}
