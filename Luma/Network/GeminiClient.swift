// Luma MVP - autogenerated by Cursor
import Foundation

/// Client for Gemini API calls (BYO key only in MVP).
/// 
/// Per SECURITY.md: Keys stored in Keychain, never in code or logs.
/// Per AGENTS.md: All network calls must be explicit and attributable to user request.
/// 
/// MVP: This is a stub that returns canned responses. Real network implementation would:
/// - Use URLSession to POST to https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent
/// - Set Authorization header: "Bearer \(apiKey)" where apiKey comes from Keychain via apiKeyProvider
/// - Parse JSON response into LLMResponse format
/// - Handle streaming responses (SRS NFR-8) if supported
final class GeminiClient {
    
    private let apiKeyProvider: () -> String?
    
    /// Initializes client with a closure that provides the API key.
    /// Key should be retrieved from Keychain (via KeychainManager) when needed.
    /// Per SECURITY.md: Never store keys in code, UserDefaults, or logs.
    init(apiKeyProvider: @escaping () -> String?) {
        self.apiKeyProvider = apiKeyProvider
    }
    
    /// Generates a response from Gemini API via HTTPS POST.
    /// 
    /// - Parameters:
    ///   - prompt: User's prompt/query
    ///   - context: Optional context (selected text or excerpt) - only when user requests
    ///   - completion: Callback with Result containing LLMResponse JSON Data or Error
    func generate(prompt: String, context: String?, completion: @escaping (Result<Data, Error>) -> Void) {
        // Fail closed if no API key
        guard let apiKey = apiKeyProvider() else {
            DispatchQueue.main.async {
                completion(.failure(NoAPIKeyError()))
            }
            return
        }
        
        // Build the request URL
        guard let url = URL(string: "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=\(apiKey)") else {
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidURL))
            }
            return
        }
        
        // Build request body
        var contents: [[String: Any]] = []
        
        // Add context first if provided
        if let context = context, !context.isEmpty {
            contents.append([
                "role": "user",
                "parts": [["text": context]]
            ])
        }
        
        // Add user prompt
        contents.append([
            "role": "user",
            "parts": [["text": prompt]]
        ])
        
        let requestBody: [String: Any] = [
            "contents": contents
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidRequest))
            }
            return
        }
        
        // Create URLRequest
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        // Make the network call
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    completion(.failure(error))
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    completion(.failure(GeminiAPIError.invalidResponse))
                    return
                }
                
                guard (200...299).contains(httpResponse.statusCode) else {
                    let statusError = GeminiAPIError.httpError(statusCode: httpResponse.statusCode)
                    completion(.failure(statusError))
                    return
                }
                
                guard let data = data else {
                    completion(.failure(GeminiAPIError.noData))
                    return
                }
                
                // Parse Gemini's response format
                do {
                    guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                          let candidates = json["candidates"] as? [[String: Any]],
                          let firstCandidate = candidates.first,
                          let content = firstCandidate["content"] as? [String: Any],
                          let parts = content["parts"] as? [[String: Any]],
                          let firstPart = parts.first,
                          let text = firstPart["text"] as? String else {
                        completion(.failure(GeminiAPIError.invalidResponseFormat))
                        return
                    }
                    
                    // Transform Gemini response into our LLMResponse format
                    // For now, we'll try to parse action from the text if it contains JSON
                    var browserAction: BrowserAction? = nil
                    
                    // Try to extract JSON action from text (simple heuristic)
                    if let jsonRange = text.range(of: "```json", options: .caseInsensitive) ?? text.range(of: "{", options: []),
                       let jsonEndRange = text.range(of: "}", options: [], range: jsonRange.upperBound..<text.endIndex) {
                        let jsonString = String(text[jsonRange.lowerBound..<jsonEndRange.upperBound])
                            .replacingOccurrences(of: "```json", with: "")
                            .replacingOccurrences(of: "```", with: "")
                            .trimmingCharacters(in: .whitespacesAndNewlines)
                        
                        if let jsonData = jsonString.data(using: .utf8),
                           let parsed = try? JSONDecoder().decode(LLMResponse.self, from: jsonData) {
                            browserAction = parsed.action
                        }
                    }
                    
                    // Create our LLMResponse
                    let lumaResponse = LLMResponse(
                        text: text,
                        action: browserAction
                    )
                    
                    // Encode back to Data
                    let encoder = JSONEncoder()
                    let responseData = try encoder.encode(lumaResponse)
                    completion(.success(responseData))
                    
                } catch {
                    completion(.failure(error))
                }
            }
        }.resume()
    }
}

/// Error returned when API key is not available.
struct NoAPIKeyError: LocalizedError {
    var errorDescription: String? {
        "No API key available. Please configure your Gemini API key in Settings."
    }
}

/// Errors that can occur during Gemini API calls.
enum GeminiAPIError: LocalizedError {
    case invalidURL
    case invalidRequest
    case invalidResponse
    case invalidResponseFormat
    case noData
    case httpError(statusCode: Int)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid Gemini API URL"
        case .invalidRequest:
            return "Failed to build request"
        case .invalidResponse:
            return "Invalid response from server"
        case .invalidResponseFormat:
            return "Response format not recognized"
        case .noData:
            return "No data received from server"
        case .httpError(let code):
            return "HTTP error: \(code)"
        }
    }
}
