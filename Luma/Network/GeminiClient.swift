// Luma MVP - autogenerated by Cursor
import Foundation

/// User-facing network error for UI display. Never contains keys or stack traces.
enum GeminiError: LocalizedError {
    case noAPIKeyOrUnauthorized
    case endpointNotFound
    case networkFailure(String)

    var errorDescription: String? {
        switch self {
        case .noAPIKeyOrUnauthorized:
            return "Unauthorized (401). Your API key is missing/invalid."
        case .endpointNotFound:
            return "Gemini API returned 404 (endpoint not found). Check provider endpoint or API version."
        case .networkFailure(let msg):
            return "Network error: \(msg)"
        }
    }
}

/// Client for Gemini API calls (BYO key only in MVP).
///
/// Per SECURITY.md: Keys stored in Keychain, never in code or logs.
/// Per AGENTS.md: All network calls must be explicit and attributable to user request.
final class GeminiClient {

    /// Last network error message (user-facing only). Cleared on success. Memory only; never logged.
    static var lastNetworkError: String?

    /// Clears client caches (e.g. lastNetworkError). Call after key save/delete in Settings.
    static func clearClientCaches() {
        lastNetworkError = nil
    }

    private let apiKeyProvider: () -> String?
    
    /// Initializes client with a closure that provides the API key.
    /// Key should be retrieved from Keychain (via KeychainManager) when needed.
    /// Per SECURITY.md: Never store keys in code, UserDefaults, or logs.
    init(apiKeyProvider: @escaping () -> String?) {
        self.apiKeyProvider = apiKeyProvider
    }
    
    /// Generates a response from Gemini API via HTTPS POST.
    /// 
    /// - Parameters:
    ///   - prompt: User's prompt/query
    ///   - context: Optional context (selected text or excerpt) - only when user requests
    ///   - completion: Callback with Result containing LLMResponse JSON Data or Error
    func generate(prompt: String, context: String?, completion: @escaping (Result<Data, Error>) -> Void) {
        // Fail closed if no API key
        guard let apiKey = apiKeyProvider() else {
            Self.lastNetworkError = "No API key available. Add key in Settings."
            DispatchQueue.main.async {
                completion(.failure(GeminiError.noAPIKeyOrUnauthorized))
            }
            return
        }

        // Build the request URL
        guard let url = URL(string: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=\(apiKey)") else {
            Self.lastNetworkError = "Invalid Gemini API URL"
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidURL))
            }
            return
        }
        
        // Build request body
        var contents: [[String: Any]] = []
        
        // Add context first if provided
        if let context = context, !context.isEmpty {
            contents.append([
                "role": "user",
                "parts": [["text": context]]
            ])
        }
        
        // Add user prompt
        contents.append([
            "role": "user",
            "parts": [["text": prompt]]
        ])
        
        let requestBody: [String: Any] = [
            "contents": contents
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: requestBody) else {
            Self.lastNetworkError = "Failed to build request"
            DispatchQueue.main.async {
                completion(.failure(GeminiAPIError.invalidRequest))
            }
            return
        }
        
        // Create URLRequest
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = jsonData
        
        // Make the network call
        URLSession.shared.dataTask(with: request) { data, response, error in
            DispatchQueue.main.async {
                if let error = error {
                    Self.lastNetworkError = "Network error: \(error.localizedDescription)"
                    completion(.failure(GeminiError.networkFailure(error.localizedDescription)))
                    return
                }

                guard let httpResponse = response as? HTTPURLResponse else {
                    Self.lastNetworkError = "Invalid response from server"
                    completion(.failure(GeminiAPIError.invalidResponse))
                    return
                }

                guard (200...299).contains(httpResponse.statusCode) else {
                    let userMsg = Self.userMessageForHTTPStatus(httpResponse.statusCode, body: data)
                    Self.lastNetworkError = userMsg
                    switch httpResponse.statusCode {
                    case 401:
                        completion(.failure(GeminiError.noAPIKeyOrUnauthorized))
                    case 404:
                        completion(.failure(GeminiError.endpointNotFound))
                    default:
                        completion(.failure(GeminiAPIError.httpError(statusCode: httpResponse.statusCode)))
                    }
                    return
                }

                guard let data = data else {
                    Self.lastNetworkError = "No data received from server"
                    completion(.failure(GeminiAPIError.noData))
                    return
                }
                
                // Parse Gemini's response format
                do {
                    guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
                          let candidates = json["candidates"] as? [[String: Any]],
                          let firstCandidate = candidates.first,
                          let content = firstCandidate["content"] as? [String: Any],
                          let parts = content["parts"] as? [[String: Any]],
                          let firstPart = parts.first,
                          let text = firstPart["text"] as? String else {
                        Self.lastNetworkError = "Response format not recognized"
                        completion(.failure(GeminiAPIError.invalidResponseFormat))
                        return
                    }
                    
                    // Transform Gemini response into our LLMResponse format
                    // For now, we'll try to parse action from the text if it contains JSON
                    var browserAction: BrowserAction? = nil
                    
                    // Try to extract JSON action from text (simple heuristic)
                    if let jsonRange = text.range(of: "```json", options: .caseInsensitive) ?? text.range(of: "{", options: []),
                       let jsonEndRange = text.range(of: "}", options: [], range: jsonRange.upperBound..<text.endIndex) {
                        let jsonString = String(text[jsonRange.lowerBound..<jsonEndRange.upperBound])
                            .replacingOccurrences(of: "```json", with: "")
                            .replacingOccurrences(of: "```", with: "")
                            .trimmingCharacters(in: .whitespacesAndNewlines)
                        
                        if let jsonData = jsonString.data(using: .utf8),
                           let parsed = try? JSONDecoder().decode(LLMResponse.self, from: jsonData) {
                            browserAction = parsed.action
                        }
                    }
                    
                    // Create our LLMResponse
                    let lumaResponse = LLMResponse(
                        text: text,
                        action: browserAction
                    )
                    
                    // Encode back to Data
                    let encoder = JSONEncoder()
                    let responseData = try encoder.encode(lumaResponse)
                    Self.lastNetworkError = nil
                    completion(.success(responseData))

                } catch {
                    Self.lastNetworkError = error.localizedDescription
                    completion(.failure(error))
                }
            }
        }.resume()
    }

    private static func userMessageForHTTPStatus(_ code: Int, body: Data?) -> String {
        switch code {
        case 401:
            return "Unauthorized (401). Your API key is missing/invalid."
        case 404:
            return "Gemini API returned 404 (endpoint not found). Check provider endpoint or API version."
        default:
            var msg = "Gemini API returned \(code)."
            if let body = body, let json = try? JSONSerialization.jsonObject(with: body) as? [String: Any],
               let err = json["error"] as? [String: Any], let m = err["message"] as? String, !m.isEmpty {
                msg += " \(m)"
            }
            return msg
        }
    }
}

/// Errors that can occur during Gemini API calls.
enum GeminiAPIError: LocalizedError {
    case invalidURL
    case invalidRequest
    case invalidResponse
    case invalidResponseFormat
    case noData
    case httpError(statusCode: Int)
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid Gemini API URL"
        case .invalidRequest:
            return "Failed to build request"
        case .invalidResponse:
            return "Invalid response from server"
        case .invalidResponseFormat:
            return "Response format not recognized"
        case .noData:
            return "No data received from server"
        case .httpError(let code):
            return "HTTP error: \(code)"
        }
    }
}
