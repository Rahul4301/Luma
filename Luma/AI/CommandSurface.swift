// Luma MVP - autogenerated by Cursor
//
// NOTE: Per AGENTS.md + SECURITY.md, page context is ONLY sent when user explicitly toggles attach chips.
// No background context polling. No automatic sends.
import Foundation
import SwiftUI
import AppKit

/// Right-side AI command panel (Cmd+E toggle). Per-tab chat with history.
///
/// Per SRS F2: Toggled via Cmd+E, dockable and dismissible.
/// Per AGENTS.md: AI is user-invoked only; no background activity.
/// Per SECURITY.md: UI must display what will be sent and require confirmation.
struct CommandSurfaceView: View {
    @Binding var isPresented: Bool
    @Binding var messages: [ChatMessage]
    let webViewWrapper: WebViewWrapper
    let commandRouter: CommandRouter
    let gemini: GeminiGenerating
    let onActionProposed: (LLMResponse) -> Void
    
    // Tab ID for tracking summaries (passed from parent)
    var tabId: UUID? = nil

    @EnvironmentObject private var tabManager: TabManager

    @AppStorage("luma_ai_panel_font_size") private var aiPanelFontSizeRaw: Int = 13
    @State private var inputText: String = ""
    @State private var isSending: Bool = false

    @State private var includeSelection: Bool = false
    @State private var includeExcerpt: Bool = false
    @State private var includeURL: Bool = false
    @State private var selectionText: String? = nil
    @State private var excerptText: String? = nil
    @State private var currentURLString: String? = nil
    @State private var excerptWasTruncated: Bool = false

    @State private var showPreviewSheet: Bool = false
    @State private var showConfirmSend: Bool = false
    @State private var confirmApproved: Bool = false
    @State private var pendingSendPayload: PendingSendPayload? = nil

    @State private var actionProposals: [UUID: LLMResponse] = [:]
    @State private var dismissedActionIds: Set<UUID> = []
    @State private var streamTask: Task<Void, Never>? = nil

    @State private var conversationSummary: String? = nil
    @State private var lastSummarizedMessageCount: Int = 0
    @FocusState private var isInputFocused: Bool

    private let panelBg = Color.black
    private let textPrimary = Color(white: 0.9)
    private let textSecondary = Color(white: 0.6)
    /// Xcode AI assistant-style glow: cyan when active, subtle when idle
    private let glowColorActive = Color(red: 0.35, green: 0.75, blue: 1.0)
    private let glowColorDim = Color(red: 0.3, green: 0.6, blue: 0.9).opacity(0.15)

    private var chatFontSize: CGFloat { CGFloat(aiPanelFontSizeRaw) }

    var body: some View {
        VStack(spacing: 0) {
            // Header: ChatGPT-style minimal (Luma + status + close)
            HStack(spacing: 8) {
                VStack(alignment: .leading, spacing: 2) {
                    Text("Luma")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(textPrimary)
                    HStack(spacing: 4) {
                        Image(systemName: "brain")
                            .font(.system(size: 8, weight: .medium))
                            .foregroundColor(textSecondary.opacity(0.7))
                        Text("Context-aware • User-invoked only")
                            .font(.system(size: 9, weight: .regular))
                            .foregroundColor(textSecondary.opacity(0.7))
                    }
                }
                statusDotView()
                if KeychainManager.shared.fetchGeminiKey() == nil || GeminiClient.lastNetworkError != nil {
                    SettingsLink { Text("Settings").font(.caption2).foregroundColor(textSecondary) }
                        .buttonStyle(.plain)
                }
                Spacer()
                Button(action: close) {
                    Image(systemName: "xmark")
                        .font(.system(size: 11, weight: .medium))
                        .foregroundColor(textSecondary)
                }
                .buttonStyle(.plain)
                .keyboardShortcut(.escape, modifiers: [])
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 12)
            .background(panelBg)

            // Chat history: freeform flow (no bubbles)
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 12) {
                        ForEach(messages) { msg in
                            FreeformMessageRow(
                                message: msg,
                                actionProposal: actionProposals[msg.id],
                                isDismissed: dismissedActionIds.contains(msg.id),
                                onRegenerate: { regenerate(from: $0) },
                                onCopy: { copyToClipboard($0) },
                                onExplainAction: { explainAction(for: $0) },
                                onExecuteAction: { message, action in executeAction(for: message, action: action) },
                                onDismissAction: { dismissedActionIds.insert($0.id) },
                                fontSize: chatFontSize
                            )
                            .transition(.move(edge: .bottom).combined(with: .opacity))
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 12)
                }
                .frame(maxHeight: .infinity)
                .onChange(of: messages.count) { _, _ in
                    if let last = messages.last {
                        withAnimation(.easeOut(duration: 0.18)) {
                            proxy.scrollTo(last.id, anchor: .bottom)
                        }
                    }
                }
            }
            .background(panelBg)

            // Input area: freeform composer + attach chips
            VStack(spacing: 10) {
                HStack(spacing: 8) {
                    AttachChip(
                        title: "Selection",
                        isOn: includeSelection,
                        detail: selectionText.map { formatCount($0.count) }
                    ) { toggleSelection() }

                    AttachChip(
                        title: "Visible excerpt",
                        isOn: includeExcerpt,
                        detail: excerptText.map { formatCount($0.count) }
                    ) { toggleExcerpt() }

                    AttachChip(
                        title: "URL",
                        isOn: includeURL,
                        detail: currentURLString.map { truncateURL($0) }
                    ) { toggleURL() }

                    Spacer()

                    Button("Preview") { showPreviewSheet = true }
                        .font(.caption)
                        .foregroundColor(textSecondary)
                        .buttonStyle(.plain)
                }

                if excerptWasTruncated {
                    Text("Excerpt truncated to 4000 characters.")
                        .font(.caption2)
                        .foregroundColor(.orange.opacity(0.9))
                        .frame(maxWidth: .infinity, alignment: .leading)
                }

                HStack(alignment: .bottom, spacing: 8) {
                    let isGlowActive = isInputFocused || !inputText.isEmpty
                    GrowingTextEditor(
                        text: $inputText,
                        placeholder: "Message Luma...",
                        minHeight: 36,
                        fontSize: chatFontSize,
                        isFocused: $isInputFocused,
                        onSubmit: sendCommand
                    )
                    .padding(10)
                    .frame(maxHeight: 120)
                    .background(Color(white: 0.12))
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isGlowActive ? glowColorActive : glowColorDim, lineWidth: isGlowActive ? 2 : 1)
                    )
                    .shadow(color: isGlowActive ? glowColorActive.opacity(0.6) : glowColorDim.opacity(0.3), radius: isGlowActive ? 12 : 4)
                    .shadow(color: isGlowActive ? glowColorActive.opacity(0.3) : .clear, radius: isGlowActive ? 24 : 0)
                    .animation(.easeInOut(duration: 0.12), value: isGlowActive)

                    Button(action: sendCommand) {
                        Image(systemName: "arrow.up.circle.fill")
                            .font(.system(size: 28))
                            .foregroundColor(inputText.isEmpty || isSending ? textSecondary.opacity(0.4) : textPrimary)
                    }
                    .buttonStyle(.plain)
                    .disabled(inputText.isEmpty || isSending)
                    .keyboardShortcut(.return, modifiers: .command)
                    .help("Send (⌘↵)")
                }

                HStack(spacing: 8) {
                    Toggle(isOn: $confirmApproved) {
                        Text("I approve sending this content")
                            .font(.caption)
                            .foregroundColor(textSecondary)
                    }
                    .toggleStyle(.checkbox)
                    .tint(textSecondary)
                    Spacer()
                }
            }
            .padding(12)
            .background(panelBg)
        }
        .background(panelBg)
        .sheet(isPresented: $showPreviewSheet) {
            SendPreviewSheet(
                selectionText: selectionText,
                excerptText: excerptText,
                urlString: currentURLString,
                excerptWasTruncated: excerptWasTruncated
            )
        }
        .confirmationDialog(
            "Confirm send",
            isPresented: $showConfirmSend,
            titleVisibility: .visible
        ) {
            Button("Cancel", role: .cancel) { clearPendingSend() }
            Button("Send") { confirmAndSendIfApproved() }
        } message: {
            Text("The content includes potentially sensitive or directive text. Review and approve before sending.")
        }
        .alert("Approval required", isPresented: Binding(
            get: { showConfirmSend && !confirmApproved },
            set: { _ in }
        )) {
            Button("OK", role: .cancel) { }
        } message: {
            Text("Please check \"I approve sending this content\" to proceed.")
        }
    }

    private func statusDotView() -> some View {
        let color: Color
        if GeminiClient.lastNetworkError != nil {
            color = .red
        } else if KeychainManager.shared.fetchGeminiKey() == nil {
            color = .gray
        } else {
            color = .green
        }
        return Circle().fill(color).frame(width: 6, height: 6)
    }

    private func close() {
        isPresented = false
        inputText = ""
        isSending = false
        clearPendingSend()
    }

    private func toggleSelection() {
        includeSelection.toggle()
        if includeSelection {
            webViewWrapper.evaluateSelectedText { text in
                selectionText = text
            }
        } else {
            selectionText = nil
        }
    }

    private func toggleExcerpt() {
        includeExcerpt.toggle()
        if includeExcerpt {
            webViewWrapper.evaluateVisibleText(maxChars: 4000) { text in
                if let text = text {
                    if text.count > 4000 {
                        excerptText = String(text.prefix(4000))
                        excerptWasTruncated = true
                    } else {
                        excerptText = text
                        excerptWasTruncated = false
                    }
                } else {
                    excerptText = nil
                    excerptWasTruncated = false
                }
            }
        } else {
            excerptText = nil
            excerptWasTruncated = false
        }
    }

    private func toggleURL() {
        includeURL.toggle()
        if includeURL {
            currentURLString = webViewWrapper.currentURL?.absoluteString
        } else {
            currentURLString = nil
        }
    }

    private func sendCommand() {
        let trimmed = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        gatherContextForSend { payload in
            pendingSendPayload = payload

            if payload.containsSuspiciousContent {
                showConfirmSend = true
            } else {
                performSend(payload: payload)
            }
        }
    }

    private func confirmAndSendIfApproved() {
        guard confirmApproved, let payload = pendingSendPayload else { return }
        performSend(payload: payload)
    }

    private func performSend(payload: PendingSendPayload) {
        isSending = true
        inputText = ""

        let userMsg = ChatMessage(
            role: .user,
            text: payload.prompt,
            pageURL: payload.urlString,
            pageTitle: nil,
            metadata: payload.metadata
        )
        messages.append(userMsg)

        let assistantId = UUID()
        let assistantMsg = ChatMessage(
            id: assistantId,
            role: .assistant,
            text: "",
            pageURL: payload.urlString,
            pageTitle: nil,
            metadata: ["provider": "Gemini"],
            isStreaming: true
        )
        messages.append(assistantMsg)

        clearPendingSend()

        let recentContext = messages.dropLast().suffix(6)

        gemini.generate(
            prompt: payload.prompt,
            context: payload.contextString,
            recentMessages: Array(recentContext),
            conversationSummary: conversationSummary
        ) { result in
            DispatchQueue.main.async {
                isSending = false

                switch result {
                case .success(let data):
                    guard let response = commandRouter.parseLLMResponse(data) else {
                        streamAppend(text: String(data: data, encoding: .utf8) ?? "", to: assistantId, finalize: true)
                        return
                    }

                    streamAppend(text: response.text, to: assistantId, finalize: true)

                    if response.action != nil {
                        actionProposals[assistantId] = response
                        markActionProposal(messageId: assistantId, hasProposal: true)
                    }

                    checkAndSummarize()

                case .failure:
                    markStreamFailed(messageId: assistantId)
                }
            }
        }
    }

    private func streamAppend(text: String, to messageId: UUID, finalize: Bool) {
        streamTask?.cancel()
        let chunks = splitIntoChunks(text: text, maxChunkSize: 24)
        streamTask = Task { [chunks] in
            for chunk in chunks {
                try? await Task.sleep(nanoseconds: 35_000_000)
                await MainActor.run {
                    appendChunk(chunk, to: messageId)
                }
            }
            if finalize {
                await MainActor.run {
                    setStreaming(false, for: messageId)
                }
            }
        }
    }

    private func appendChunk(_ chunk: String, to messageId: UUID) {
        guard let idx = messages.firstIndex(where: { $0.id == messageId }) else { return }
        messages[idx].text += chunk
    }

    private func setStreaming(_ streaming: Bool, for messageId: UUID) {
        guard let idx = messages.firstIndex(where: { $0.id == messageId }) else { return }
        messages[idx].isStreaming = streaming
    }

    private func markActionProposal(messageId: UUID, hasProposal: Bool) {
        guard let idx = messages.firstIndex(where: { $0.id == messageId }) else { return }
        messages[idx].metadata["action_proposal"] = hasProposal ? "true" : "false"
    }

    private func markStreamFailed(messageId: UUID) {
        guard let idx = messages.firstIndex(where: { $0.id == messageId }) else { return }
        messages[idx].isStreaming = false
        messages[idx].isError = true
        messages[idx].text += "\n\n[stream failed]"
    }

    private func regenerate(from message: ChatMessage) {
        inputText = "Regenerate the previous response with the same intent and context."
        sendCommand()
    }

    private func explainAction(for message: ChatMessage) {
        inputText = "Explain the proposed action in plain language and list any risks."
        sendCommand()
    }

    private func executeAction(for message: ChatMessage, action: BrowserAction) -> Result<String, Error> {
        return ActionExecutionBroker.execute(
            action: action,
            tabManager: tabManager,
            commandRouter: commandRouter
        )
    }

    private func copyToClipboard(_ text: String) {
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(text, forType: .string)
    }

    private func gatherContextForSend(completion: @escaping (PendingSendPayload) -> Void) {
        let prompt = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        var parts: [String] = []
        var metadata: [String: String] = [:]
        var contextCount = 0

        let group = DispatchGroup()

        if includeSelection {
            group.enter()
            webViewWrapper.evaluateSelectedText { text in
                if let text = text, !text.isEmpty {
                    parts.append("Selection:\n\(text)")
                    metadata["sent_context"] = appendContextLabel(metadata["sent_context"], "selection")
                    contextCount += text.count
                }
                group.leave()
            }
        }

        if includeExcerpt {
            group.enter()
            webViewWrapper.evaluateVisibleText(maxChars: 4000) { text in
                if let text = text, !text.isEmpty {
                    let truncated = text.count > 4000 ? String(text.prefix(4000)) : text
                    parts.append("Visible excerpt:\n\(truncated)")
                    metadata["sent_context"] = appendContextLabel(metadata["sent_context"], "excerpt")
                    contextCount += truncated.count
                }
                group.leave()
            }
        }

        if includeURL, let urlString = webViewWrapper.currentURL?.absoluteString {
            parts.append("URL: \(urlString)")
            metadata["sent_context"] = appendContextLabel(metadata["sent_context"], "url")
            currentURLString = urlString
            contextCount += urlString.count
        }

        group.notify(queue: .main) {
            if contextCount > 0 {
                metadata["context_chars"] = "\(contextCount)"
            }

            let contextString = parts.isEmpty ? nil : parts.joined(separator: "\n\n")
            let containsSuspicious = containsSuspiciousContent(contextString)

            completion(PendingSendPayload(
                prompt: prompt,
                contextString: contextString,
                urlString: currentURLString,
                metadata: metadata,
                containsSuspiciousContent: containsSuspicious
            ))
        }
    }

    private func clearPendingSend() {
        pendingSendPayload = nil
        confirmApproved = false
        showConfirmSend = false
    }

    private func checkAndSummarize() {
        let messagesToSummarize = messages.count - lastSummarizedMessageCount
        if messagesToSummarize >= 8 {
            let messagesToProcess = Array(messages.suffix(messagesToSummarize))
            gemini.summarizeConversation(messages: messagesToProcess) { result in
                DispatchQueue.main.async {
                    switch result {
                    case .success(let summary):
                        if let existing = conversationSummary {
                            conversationSummary = "\(existing)\n\nRecent: \(summary)"
                        } else {
                            conversationSummary = summary
                        }
                        lastSummarizedMessageCount = messages.count
                        if let tabId = tabId {
                            let summaryObj = ConversationSummary(
                                tabId: tabId,
                                summary: summary,
                                messageRange: (messages.count - messagesToSummarize)...(messages.count - 1)
                            )
                            HistoryManager.shared.addConversationSummary(tabId: tabId, summary: summaryObj)
                        }
                    case .failure:
                        break
                    }
                }
            }
        }
    }

    private func formatCount(_ count: Int) -> String {
        if count >= 1000 { return String(format: "%.1fk", Double(count) / 1000.0) }
        return "\(count)"
    }

    private func truncateURL(_ url: String) -> String {
        if url.count <= 20 { return url }
        let prefix = url.prefix(12)
        let suffix = url.suffix(6)
        return "\(prefix)…\(suffix)"
    }
}

// MARK: - Pending send

private struct PendingSendPayload {
    let prompt: String
    let contextString: String?
    let urlString: String?
    let metadata: [String: String]
    let containsSuspiciousContent: Bool
}

private func appendContextLabel(_ existing: String?, _ newLabel: String) -> String {
    if let existing = existing, !existing.isEmpty {
        return "\(existing), \(newLabel)"
    }
    return newLabel
}

private func containsSuspiciousContent(_ content: String?) -> Bool {
    guard let content = content, !content.isEmpty else { return false }
    let pattern = "(?i)tell the ai|navigate to|send to server|password|secret"
    return content.range(of: pattern, options: .regularExpression) != nil
}

private func splitIntoChunks(text: String, maxChunkSize: Int) -> [String] {
    guard maxChunkSize > 0 else { return [text] }
    var chunks: [String] = []
    var current = ""
    for ch in text {
        current.append(ch)
        if current.count >= maxChunkSize {
            chunks.append(current)
            current = ""
        }
    }
    if !current.isEmpty { chunks.append(current) }
    return chunks
}

// MARK: - Preview sheet

private struct SendPreviewSheet: View {
    let selectionText: String?
    let excerptText: String?
    let urlString: String?
    let excerptWasTruncated: Bool

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Preview")
                .font(.headline)
            if let selectionText = selectionText, !selectionText.isEmpty {
                Text("Selection")
                    .font(.caption)
                Text(selectionText)
                    .font(.system(size: 12))
                    .textSelection(.enabled)
            }
            if let excerptText = excerptText, !excerptText.isEmpty {
                HStack(spacing: 6) {
                    Text("Visible excerpt")
                        .font(.caption)
                    if excerptWasTruncated {
                        Text("(truncated)")
                            .font(.caption2)
                            .foregroundColor(.orange)
                    }
                }
                Text(excerptText)
                    .font(.system(size: 12))
                    .textSelection(.enabled)
            }
            if let urlString = urlString, !urlString.isEmpty {
                Text("URL")
                    .font(.caption)
                Text(urlString)
                    .font(.system(size: 12))
                    .textSelection(.enabled)
            }
            Spacer()
        }
        .padding(16)
        .frame(minWidth: 420, minHeight: 320)
    }
}

// MARK: - Attach chip

private struct AttachChip: View {
    let title: String
    let isOn: Bool
    let detail: String?
    let onTap: () -> Void

    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 6) {
                Image(systemName: isOn ? "checkmark.circle.fill" : "circle")
                    .font(.system(size: 11, weight: .semibold))
                Text(title)
                    .font(.caption)
                if let detail = detail {
                    Text(detail)
                        .font(.caption2)
                        .foregroundColor(.white.opacity(0.7))
                }
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(isOn ? Color(white: 0.2) : Color(white: 0.12))
            .clipShape(Capsule())
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Action execution broker

private enum ActionExecutionBroker {
    static func execute(action: BrowserAction, tabManager: TabManager, commandRouter: CommandRouter) -> Result<String, Error> {
        return commandRouter.execute(action: action, tabManager: tabManager)
    }
}

// MARK: - Gemini protocol for tests

protocol GeminiGenerating {
    func generate(prompt: String, context: String?, recentMessages: [ChatMessage], conversationSummary: String?, completion: @escaping (Result<Data, Error>) -> Void)
    func summarizeConversation(messages: [ChatMessage], completion: @escaping (Result<String, Error>) -> Void)
}

extension GeminiClient: GeminiGenerating {}

// MARK: - Growing multiline text editor

private struct TextHeightKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

private struct GrowingTextEditor: View {
    @Binding var text: String
    var placeholder: String
    var minHeight: CGFloat
    var fontSize: CGFloat = 13
    @FocusState.Binding var isFocused: Bool
    var onSubmit: (() -> Void)? = nil

    /// Height from content; no upper bound so the whole query is visible.
    @State private var contentHeight: CGFloat = 36

    private var font: Font { Font.system(size: fontSize) }
    private let textColor = Color(white: 0.9)
    private let placeholderColor = Color(white: 0.5)

    private var boxHeight: CGFloat {
        max(minHeight, contentHeight)
    }

    var body: some View {
        ZStack(alignment: .topLeading) {
            // Measure content height using invisible text (opacity 0 so no double-text overlay)
            Text(text.isEmpty ? " " : text)
                .font(font)
                .foregroundColor(textColor)
                .frame(maxWidth: .infinity, alignment: .topLeading)
                .fixedSize(horizontal: false, vertical: true)
                .padding(8)
                .opacity(0)
                .background(
                    GeometryReader { g in
                        Color.clear.preference(key: TextHeightKey.self, value: g.size.height)
                    }
                )
                .allowsHitTesting(false)

            EnterSubmittingTextEditor(
                text: $text,
                fontSize: fontSize,
                minHeight: minHeight,
                onSubmit: onSubmit
            )
            .focused($isFocused)
            .frame(height: boxHeight)

            if text.isEmpty {
                Text(placeholder)
                    .font(font)
                    .foregroundColor(placeholderColor)
                    .padding(12)
                    .frame(maxWidth: .infinity, alignment: .topLeading)
                    .frame(height: boxHeight)
                    .allowsHitTesting(false)
            }
        }
        .frame(height: boxHeight)
        .onPreferenceChange(TextHeightKey.self) { h in
            contentHeight = max(minHeight, h)
        }
    }
}

// MARK: - Enter-submitting NSTextView (Return sends, Shift+Return newline)

private final class EnterSubmittingTextView: NSScrollView {
    private let onSubmit: (() -> Void)?
    private var textView: NSTextView!
    var onTextChange: ((String) -> Void)?
    var fontSize: CGFloat = 13 { didSet { textView?.font = .systemFont(ofSize: fontSize) } }

    init(onSubmit: (() -> Void)?, fontSize: CGFloat) {
        self.onSubmit = onSubmit
        self.fontSize = fontSize
        super.init(frame: .zero)
        hasVerticalScroller = true
        hasHorizontalScroller = false
        autohidesScrollers = true
        borderType = .noBorder
        drawsBackground = false

        let tv = NSTextView()
        tv.isRichText = false
        tv.drawsBackground = false
        tv.font = .systemFont(ofSize: fontSize)
        tv.textColor = NSColor(white: 0.9, alpha: 1)
        tv.isAutomaticQuoteSubstitutionEnabled = false
        tv.isAutomaticDashSubstitutionEnabled = false
        tv.isAutomaticTextReplacementEnabled = false
        documentView = tv
        textView = tv
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    func setDelegate(_ delegate: NSTextViewDelegate?) {
        textView.delegate = delegate
    }

    func setText(_ string: String) {
        textView.string = string
    }

    override func keyDown(with event: NSEvent) {
        if event.keyCode == 36, !event.modifierFlags.contains(.shift) {
            onSubmit?()
            return
        }
        super.keyDown(with: event)
    }
}

private struct EnterSubmittingTextEditor: NSViewRepresentable {
    @Binding var text: String
    var fontSize: CGFloat
    var minHeight: CGFloat
    var onSubmit: (() -> Void)?

    func makeNSView(context: Context) -> EnterSubmittingTextView {
        let view = EnterSubmittingTextView(onSubmit: onSubmit, fontSize: fontSize)
        view.setText(text)
        view.setDelegate(context.coordinator)
        return view
    }

    func updateNSView(_ nsView: EnterSubmittingTextView, context: Context) {
        if let tv = nsView.documentView as? NSTextView, tv.string != text {
            tv.string = text
        }
        nsView.fontSize = fontSize
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EnterSubmittingTextEditor

        init(_ parent: EnterSubmittingTextEditor) {
            self.parent = parent
        }

        func textDidChange(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else { return }
            parent.text = textView.string
        }
    }
}
