// Luma MVP - autogenerated by Cursor
import Foundation
import SwiftUI
import AppKit

/// Right-side AI command panel (Cmd+E toggle). Per-tab chat with history.
///
/// Per SRS F2: Toggled via Cmd+E, dockable and dismissible.
/// Per AGENTS.md: AI is user-invoked only; no background activity.
/// Per SECURITY.md: UI must display what will be sent and require confirmation.
struct CommandSurfaceView: View {
    @Binding var isPresented: Bool
    @Binding var messages: [ChatMessage]
    let webViewWrapper: WebViewWrapper
    let commandRouter: CommandRouter
    let gemini: GeminiClient
    let onActionProposed: (LLMResponse) -> Void
    
    // Tab ID for tracking summaries (passed from parent)
    var tabId: UUID? = nil

    @AppStorage("luma_ai_panel_font_size") private var aiPanelFontSizeRaw: Int = 13
    @State private var inputText: String = ""
    @State private var errorMessage: String? = nil
    @State private var isSending: Bool = false
    @State private var actionProposedMessage: String? = nil
    @State private var includeSelection: Bool = false
    @State private var selectedText: String? = nil
    @State private var whatWillBeSentExpanded: Bool = false
    @State private var conversationSummary: String? = nil
    @State private var lastSummarizedMessageCount: Int = 0
    @FocusState private var isInputFocused: Bool

    // Auto-loaded page context (always enabled for agentic behavior)
    @State private var pageTitle: String? = nil
    @State private var pageText: String? = nil
    @State private var isLoadingContext: Bool = false
    @State private var contextRefreshTimer: Timer? = nil

    private let panelBg = Color.black
    private let textPrimary = Color(white: 0.9)
    private let textSecondary = Color(white: 0.6)
    /// Xcode AI assistant-style glow: cyan when active, subtle when idle
    private let glowColorActive = Color(red: 0.35, green: 0.75, blue: 1.0)
    private let glowColorDim = Color(red: 0.3, green: 0.6, blue: 0.9).opacity(0.15)

    private var chatFontSize: CGFloat { CGFloat(aiPanelFontSizeRaw) }

    var body: some View {
        VStack(spacing: 0) {
            // Header: ChatGPT-style minimal (Luma + status + close)
            HStack(spacing: 8) {
                VStack(alignment: .leading, spacing: 2) {
                    Text("Luma")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(textPrimary)
                    HStack(spacing: 4) {
                        Image(systemName: "brain")
                            .font(.system(size: 8, weight: .medium))
                            .foregroundColor(textSecondary.opacity(0.7))
                        Text("Context-aware • Recent context")
                            .font(.system(size: 9, weight: .regular))
                            .foregroundColor(textSecondary.opacity(0.7))
                    }
                }
                statusDotView()
                if KeychainManager.shared.fetchGeminiKey() == nil || GeminiClient.lastNetworkError != nil {
                    SettingsLink { Text("Settings").font(.caption2).foregroundColor(textSecondary) }
                        .buttonStyle(.plain)
                }
                Spacer()
                Button(action: close) {
                    Image(systemName: "xmark")
                        .font(.system(size: 11, weight: .medium))
                        .foregroundColor(textSecondary)
                }
                .buttonStyle(.plain)
                .keyboardShortcut(.escape, modifiers: [])
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 12)
            .background(panelBg)

            // Collapsible "What will be sent" (context always included)
            DisclosureGroup(isExpanded: $whatWillBeSentExpanded) {
                contextPreviewContent()
                    .font(.system(size: 11))
                    .foregroundColor(textSecondary)
                    .padding(.top, 4)
            } label: {
                Text("Context (always included)")
                    .font(.caption)
                    .foregroundColor(textSecondary)
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 6)
            .background(panelBg)
            .tint(textSecondary)

            // Chat history: plain free-form text (no bubbles)
            ScrollViewReader { proxy in
                ScrollView {
                    LazyVStack(alignment: .leading, spacing: 20) {
                        ForEach(messages) { msg in
                            ChatBubble(message: msg, isUser: msg.role == .user, fontSize: chatFontSize)
                        }
                    }
                    .padding(.horizontal, 14)
                    .padding(.vertical, 12)
                }
                .frame(maxHeight: .infinity)
                .onChange(of: messages.count) { _, _ in
                    if let last = messages.last {
                        withAnimation(.easeOut(duration: 0.18)) {
                            proxy.scrollTo(last.id, anchor: .bottom)
                        }
                    }
                }
            }
            .background(panelBg)

            // Input area: ChatGPT-style with Xcode AI assistant glow
            VStack(spacing: 8) {
                HStack(alignment: .bottom, spacing: 8) {
                    let isGlowActive = isInputFocused || !inputText.isEmpty
                    GrowingTextEditor(
                        text: $inputText,
                        placeholder: "Message Luma...",
                        minHeight: 36,
                        fontSize: chatFontSize,
                        isFocused: $isInputFocused,
                        onSubmit: sendCommand
                    )
                    .padding(10)
                    .frame(maxHeight: 80)
                    .background(Color(white: 0.12))
                    .clipShape(RoundedRectangle(cornerRadius: 12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(isGlowActive ? glowColorActive : glowColorDim, lineWidth: isGlowActive ? 2 : 1)
                    )
                    .shadow(color: isGlowActive ? glowColorActive.opacity(0.6) : glowColorDim.opacity(0.3), radius: isGlowActive ? 12 : 4)
                    .shadow(color: isGlowActive ? glowColorActive.opacity(0.3) : .clear, radius: isGlowActive ? 24 : 0)
                    .animation(.easeInOut(duration: 0.12), value: isGlowActive)

                    Button(action: sendCommand) {
                        Image(systemName: "arrow.up.circle.fill")
                            .font(.system(size: 28))
                            .foregroundColor(inputText.isEmpty ? textSecondary.opacity(0.4) : textPrimary)
                    }
                    .buttonStyle(.plain)
                    .disabled(inputText.isEmpty || isSending)
                    .keyboardShortcut(.return, modifiers: .command)
                    .help("Send (Enter or ⌘↵)")
                }

                HStack(spacing: 12) {
                    Toggle(isOn: $includeSelection) {
                        Text("Include selection")
                            .font(.caption)
                            .foregroundColor(textSecondary)
                    }
                    .toggleStyle(.checkbox)
                    .tint(textSecondary)
                    .onChange(of: includeSelection) { _, on in
                        if on { fetchSelectedText() }
                        else { selectedText = nil }
                    }

                    if let msg = actionProposedMessage {
                        Text(msg)
                            .font(.caption2)
                            .foregroundColor(textSecondary)
                    }
                    if let err = errorMessage {
                        Text(err)
                            .font(.caption2)
                            .foregroundColor(.red.opacity(0.9))
                            .lineLimit(1)
                    }
                    Spacer(minLength: 0)
                }
            }
            .padding(12)
            .background(panelBg)
        }
        .background(panelBg)
        .onAppear {
            loadPageContext()
            startContextRefreshTimer()
        }
        .onDisappear {
            stopContextRefreshTimer()
        }
    }

    @ViewBuilder
    private func statusDotView() -> some View {
        let (color, _) = statusDotState()
        Circle()
            .fill(color)
            .frame(width: 6, height: 6)
    }

    private func statusDotState() -> (Color, String) {
        if GeminiClient.lastNetworkError != nil {
            return (.red, "Error")
        }
        if KeychainManager.shared.fetchGeminiKey() == nil {
            return (.gray, "No key")
        }
        return (.green, "Ready")
    }

    private func sendIfEnter() {
        if !inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            sendCommand()
        }
    }

    private struct ChatBubble: View {
        let message: ChatMessage
        let isUser: Bool
        let fontSize: CGFloat

        private let userBubbleColor = Color(white: 0.28)
        private let textColor = Color(white: 0.88)

        var body: some View {
            HStack(alignment: .top, spacing: 0) {
                if isUser { Spacer(minLength: 32) }
                if isUser {
                    messageTextView
                        .padding(.horizontal, 12)
                        .padding(.vertical, 10)
                        .background(userBubbleColor)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                        .frame(maxWidth: .infinity, alignment: .trailing)
                } else {
                    messageTextView
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                if !isUser { Spacer(minLength: 32) }
            }
        }

        @ViewBuilder
        private var messageTextView: some View {
            Group {
                if let attributed = try? AttributedString(markdown: message.text) {
                    Text(attributed)
                } else {
                    Text(message.text)
                }
            }
            .font(.system(size: fontSize))
            .foregroundColor(isUser ? .white : textColor)
            .textSelection(.enabled)
            .multilineTextAlignment(isUser ? .trailing : .leading)
            .lineSpacing(isUser ? 0 : 5)
            .fixedSize(horizontal: false, vertical: true)
        }
    }

    private func fetchSelectedText() {
        webViewWrapper.evaluateSelectedText { text in
            selectedText = text
        }
    }

    @ViewBuilder
    private func contextPreviewContent() -> some View {
        VStack(alignment: .leading, spacing: 4) {
            // Page context is always included
            if let url = webViewWrapper.currentURL {
                Text("URL: \(url.absoluteString)")
                    .foregroundColor(Color(white: 0.65))
                    .lineLimit(1)
            }
            if let title = pageTitle, !title.isEmpty {
                Text("Title: \(title)")
                    .foregroundColor(Color(white: 0.65))
                    .lineLimit(1)
            }
            if let text = pageText, !text.isEmpty {
                Text("Page: \(text.prefix(200))\(text.count > 200 ? "…" : "")")
                    .foregroundColor(Color(white: 0.65))
                    .lineLimit(3)
            }
            if includeSelection, let sel = selectedText, !sel.isEmpty {
                Text("Selection: \(sel.prefix(100))\(sel.count > 100 ? "…" : "")")
                    .foregroundColor(Color(white: 0.65))
                    .lineLimit(2)
            }
            if isLoadingContext {
                ProgressView()
                    .scaleEffect(0.6)
                    .tint(.white)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    private func close() {
        stopContextRefreshTimer()
        isPresented = false
        inputText = ""
        errorMessage = nil
        isSending = false
        actionProposedMessage = nil
    }

    /// Starts a timer to refresh context every 3 seconds.
    private func startContextRefreshTimer() {
        stopContextRefreshTimer()
        contextRefreshTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: true) { _ in
            loadPageContext()
        }
    }

    /// Stops the context refresh timer.
    private func stopContextRefreshTimer() {
        contextRefreshTimer?.invalidate()
        contextRefreshTimer = nil
    }

    /// Loads page context (title + visible text) when panel appears.
    private func loadPageContext() {
        isLoadingContext = true
        let group = DispatchGroup()

        group.enter()
        webViewWrapper.evaluatePageTitle { title in
            pageTitle = title
            group.leave()
        }

        group.enter()
        webViewWrapper.evaluateVisibleText(maxChars: 4000) { text in
            pageText = text
            group.leave()
        }

        group.notify(queue: .main) {
            isLoadingContext = false
        }
    }

    /// Builds context string from page metadata and/or selection.
    /// Page context is always included for agentic behavior.
    private func buildContextString() -> String? {
        var parts: [String] = []

        // Always include page context
        if let url = webViewWrapper.currentURL {
            parts.append("URL: \(url.absoluteString)")
        }
        if let title = pageTitle, !title.isEmpty {
            parts.append("Title: \(title)")
        }
        if let text = pageText, !text.isEmpty {
            parts.append("Page content:\n\(text)")
        }

        if includeSelection, let sel = selectedText, !sel.isEmpty {
            parts.append("Selection:\n\(sel)")
        }

        return parts.isEmpty ? nil : parts.joined(separator: "\n")
    }

    private func sendCommand() {
        let trimmed = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }

        isSending = true
        errorMessage = nil
        actionProposedMessage = nil

        let userMsg = ChatMessage(
            role: .user,
            text: trimmed,
            pageURL: webViewWrapper.currentURL?.absoluteString,
            pageTitle: pageTitle
        )
        messages.append(userMsg)
        inputText = ""

        let context = buildContextString()
        proceedWithSend(prompt: trimmed, context: context)
    }

    private func proceedWithSend(prompt: String, context: String?) {
        let promptToSend = prompt
        let contextToSend = context
        
        // Only send last 4-6 messages for immediate context to save tokens
        let recentContext = messages.dropLast().suffix(6)

        gemini.generate(
            prompt: promptToSend,
            context: contextToSend,
            recentMessages: Array(recentContext),
            conversationSummary: conversationSummary
        ) { result in
            DispatchQueue.main.async {
                isSending = false

                switch result {
                case .success(let data):
                    if let response = try? JSONDecoder().decode(LLMResponse.self, from: data) {
                        let assistantMsg = ChatMessage(
                            role: .assistant,
                            text: response.text,
                            pageURL: webViewWrapper.currentURL?.absoluteString,
                            pageTitle: pageTitle
                        )
                        messages.append(assistantMsg)
                        
                        // Auto-summarize every 8 messages
                        checkAndSummarize()
                        
                        if response.action != nil {
                            onActionProposed(response)
                            actionProposedMessage = "Action proposed"
                        }
                    } else {
                        errorMessage = "Failed to parse response"
                    }

                case .failure(let error):
                    let msg = error.localizedDescription
                    errorMessage = msg
                    let errorMsg = ChatMessage(role: .assistant, text: "Error: \(msg)")
                    messages.append(errorMsg)
                    actionProposedMessage = nil
                }
            }
        }
    }
    
    private func checkAndSummarize() {
        // Auto-summarize every 8 messages (4 exchanges)
        let messagesToSummarize = messages.count - lastSummarizedMessageCount
        
        if messagesToSummarize >= 8 {
            let messagesToProcess = Array(messages.suffix(messagesToSummarize))
            
            gemini.summarizeConversation(messages: messagesToProcess) { result in
                DispatchQueue.main.async {
                    switch result {
                    case .success(let summary):
                        // Append to existing summary or create new one
                        if let existing = conversationSummary {
                            conversationSummary = "\(existing)\n\nRecent: \(summary)"
                        } else {
                            conversationSummary = summary
                        }
                        lastSummarizedMessageCount = messages.count
                        
                        // Save summary to history if we have a tab ID
                        if let tabId = tabId {
                            let summaryObj = ConversationSummary(
                                tabId: tabId,
                                summary: summary,
                                messageRange: (messages.count - messagesToSummarize)...(messages.count - 1)
                            )
                            HistoryManager.shared.addConversationSummary(tabId: tabId, summary: summaryObj)
                        }
                        
                    case .failure:
                        // Silently fail - summarization is optimization, not critical
                        break
                    }
                }
            }
        }
    }
}

// MARK: - Growing multiline text editor

private struct TextHeightKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}

private struct GrowingTextEditor: View {
    @Binding var text: String
    var placeholder: String
    var minHeight: CGFloat
    var fontSize: CGFloat = 13
    @FocusState.Binding var isFocused: Bool
    var onSubmit: (() -> Void)? = nil

    /// Height from content; no upper bound so the whole query is visible.
    @State private var contentHeight: CGFloat = 36

    private var font: Font { Font.system(size: fontSize) }
    private let textColor = Color(white: 0.9)
    private let placeholderColor = Color(white: 0.5)

    private var boxHeight: CGFloat {
        max(minHeight, contentHeight)
    }

    var body: some View {
        ZStack(alignment: .topLeading) {
            // Measure content height using invisible text (opacity 0 so no double-text overlay)
            Text(text.isEmpty ? " " : text)
                .font(font)
                .foregroundColor(textColor)
                .frame(maxWidth: .infinity, alignment: .topLeading)
                .fixedSize(horizontal: false, vertical: true)
                .padding(8)
                .opacity(0)
                .background(
                    GeometryReader { g in
                        Color.clear.preference(key: TextHeightKey.self, value: g.size.height)
                    }
                )
                .allowsHitTesting(false)

            EnterSubmittingTextEditor(
                text: $text,
                fontSize: fontSize,
                minHeight: minHeight,
                onSubmit: onSubmit
            )
            .focused($isFocused)
            .frame(height: boxHeight)

            if text.isEmpty {
                Text(placeholder)
                    .font(font)
                    .foregroundColor(placeholderColor)
                    .padding(12)
                    .frame(maxWidth: .infinity, alignment: .topLeading)
                    .frame(height: boxHeight)
                    .allowsHitTesting(false)
            }
        }
        .frame(height: boxHeight)
        .onPreferenceChange(TextHeightKey.self) { h in
            contentHeight = max(minHeight, h)
        }
    }
}

// MARK: - Enter-submitting NSTextView (Return sends, Shift+Return newline)

private final class EnterSubmittingTextView: NSScrollView {
    private let onSubmit: (() -> Void)?
    private var textView: NSTextView!
    var onTextChange: ((String) -> Void)?
    var fontSize: CGFloat = 13 { didSet { textView?.font = .systemFont(ofSize: fontSize) } }

    init(onSubmit: (() -> Void)?, fontSize: CGFloat) {
        self.onSubmit = onSubmit
        self.fontSize = fontSize
        super.init(frame: .zero)
        hasVerticalScroller = true
        hasHorizontalScroller = false
        autohidesScrollers = true
        borderType = .noBorder
        drawsBackground = false

        let tv = NSTextView()
        tv.isRichText = false
        tv.drawsBackground = false
        tv.font = .systemFont(ofSize: fontSize)
        tv.textColor = NSColor(white: 0.9, alpha: 1)
        tv.isAutomaticQuoteSubstitutionEnabled = false
        tv.isAutomaticDashSubstitutionEnabled = false
        tv.isAutomaticTextReplacementEnabled = false
        documentView = tv
        textView = tv
    }

    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    func setDelegate(_ delegate: NSTextViewDelegate?) {
        textView.delegate = delegate
    }

    func setText(_ string: String) {
        textView.string = string
    }

    override func keyDown(with event: NSEvent) {
        if event.keyCode == 36, !event.modifierFlags.contains(.shift) {
            onSubmit?()
            return
        }
        super.keyDown(with: event)
    }
}

private struct EnterSubmittingTextEditor: NSViewRepresentable {
    @Binding var text: String
    var fontSize: CGFloat
    var minHeight: CGFloat
    var onSubmit: (() -> Void)?

    func makeNSView(context: Context) -> EnterSubmittingTextView {
        let view = EnterSubmittingTextView(onSubmit: onSubmit, fontSize: fontSize)
        view.setText(text)
        view.setDelegate(context.coordinator)
        return view
    }

    func updateNSView(_ nsView: EnterSubmittingTextView, context: Context) {
        if let tv = nsView.documentView as? NSTextView, tv.string != text {
            tv.string = text
        }
        nsView.fontSize = fontSize
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    class Coordinator: NSObject, NSTextViewDelegate {
        var parent: EnterSubmittingTextEditor

        init(_ parent: EnterSubmittingTextEditor) {
            self.parent = parent
        }

        func textDidChange(_ notification: Notification) {
            guard let textView = notification.object as? NSTextView else { return }
            parent.text = textView.string
        }
    }
}
