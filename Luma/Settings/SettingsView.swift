// Luma MVP - autogenerated by Cursor
import Foundation
import SwiftUI
import AppKit

/// Settings view for API key management and authentication.
///
/// Per SRS F5: Settings UI for AI enable/disable, Gemini API key input, and sign-in.
/// Per SECURITY.md: Keys handled via KeychainManager only; UI never stores tokens directly.
/// Per SECURITY.md: Keys must not be pre-populated in plain text fields.
struct SettingsView: View {
    @ObservedObject private var auth = SupabaseAuth.shared
    
    // Gemini BYO key state
    @State private var keyInput: String = ""
    @State private var statusText: String = ""
    @State private var hasKey: Bool = false
    
    // Auth state
    @State private var authErrorMessage: String? = nil
    @State private var isProcessing: Bool = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            Text("Settings")
                .font(.largeTitle)
                .padding(.bottom)
            
            // Gemini API Key Section
            VStack(alignment: .leading, spacing: 12) {
                Text("Gemini API Key (BYO)")
                    .font(.headline)
                
                Text("Enter your Gemini API key. It will be stored securely in Keychain.")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                SecureField("Enter API key", text: $keyInput)
                    .textFieldStyle(.roundedBorder)
                    .disabled(isProcessing)
                
                // Read-only key status row
                Text("Status: " + (hasKey ? "Stored" : "Missing"))
                    .font(.caption)
                    .foregroundColor(hasKey ? .green : .secondary)
                
                // Detailed status text
                if !statusText.isEmpty {
                    Text(statusText)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                
                HStack(spacing: 12) {
                    Button("Save Key") {
                        saveKey()
                    }
                    .disabled(isProcessing)
                    
                    Button("Delete Key") {
                        deleteKey()
                    }
                    .disabled(isProcessing || !hasKey)
                }
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(8)
            
            Divider()
            
            // Authentication Section (stubbed for Supabase)
            VStack(alignment: .leading, spacing: 12) {
                Text("Authentication")
                    .font(.headline)
                
                if auth.isSignedIn {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Signed in")
                            .font(.subheadline)
                            .foregroundColor(.green)
                        
                        if let email = auth.userEmail {
                            Text("Email: \(email)")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Button("Sign Out") {
                            auth.signOut()
                        }
                    }
                } else {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Not signed in")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                        
                        Button("Sign in with Google") {
                            signInWithGoogle()
                        }
                        .disabled(isProcessing)
                    }
                }
                
                if let errorMessage = authErrorMessage {
                    Text(errorMessage)
                        .font(.caption)
                        .foregroundColor(.red)
                }
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(8)
            
            Spacer()
        }
        .padding()
        .frame(width: 500, height: 400)
        .onAppear(perform: loadKeyStatus)
    }
    
    private func loadKeyStatus() {
        let existingKey = KeychainManager.shared.fetchGeminiKey()
        hasKey = (existingKey != nil)
        statusText = hasKey ? "Key stored in Keychain" : "No Gemini key saved"
    }
    
    private func saveKey() {
        let trimmed = keyInput.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else {
            statusText = "Key cannot be empty"
            return
        }
        
        isProcessing = true
        statusText = ""
        
        do {
            try KeychainManager.shared.storeGeminiKey(trimmed)
            hasKey = true
            keyInput = "" // Clear input field for security
            statusText = "Key saved to Keychain"
        } catch {
            statusText = "Error saving key: \(error.localizedDescription)"
        }
        
        isProcessing = false
    }
    
    private func deleteKey() {
        isProcessing = true
        statusText = ""
        
        do {
            try KeychainManager.shared.deleteGeminiKey()
            hasKey = false
            statusText = "Key deleted"
        } catch {
            statusText = "Error deleting key: \(error.localizedDescription)"
        }
        
        isProcessing = false
    }
    
    private func signInWithGoogle() {
        guard let window = NSApplication.shared.windows.first else {
            authErrorMessage = "No window available"
            return
        }
        
        isProcessing = true
        authErrorMessage = nil
        
        SupabaseAuth.shared.signInWithGoogle(presentingWindow: window) { result in
            DispatchQueue.main.async {
                isProcessing = false
                
                switch result {
                case .success:
                    authErrorMessage = nil
                case .failure(let error):
                    if error is NotConfiguredError {
                        authErrorMessage = "Authentication not configured. Please configure Supabase settings."
                    } else {
                        authErrorMessage = "Error: \(error.localizedDescription)"
                    }
                }
            }
        }
    }
}
